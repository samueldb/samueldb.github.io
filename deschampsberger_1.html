<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link href="http://code.jquery.com/ui/1.11.4/themes/ui-lightness/jquery-ui.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script src="http://libs.cartocdn.com/cartodb.js/v3/3.15/cartodb.js" type="text/javascript"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js" type="text/javascript"></script>
    <style>
        svg{
          cursor: all-scroll;
        }
        .centralText{
          font: 23spx sans-serif;
          fill: #222;
          font-weight: bold;
        }
        .downwardNode circle{
          fill: #fff;
          stroke: #8b4513;
          stroke-width: 2.5px;
        }
        .upwardNode circle {
          fill: #fff;
          stroke: #37592b;
          stroke-width: 2.5px;
        }
        .downwardNode text,
        .upwardNode text {
          font: 12px sans-serif;
          font-weight:bold;
        }
        .downwardLink {
          fill: none;
          stroke: #8b4513;
          stroke-width: 3px;
          opacity: 0.2;
        }
        .upwardLink {
          fill: none;
          stroke: #37592b;
          stroke-width: 3px;
          opacity: 0.2;
        }
</style>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Travaux Carto</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Travaux Carto</h1>
        <h2 style="text-align:right;">by Samuel Deschamps Berger</h2>
        <a class="WIP" style="width:250px;height: 140px;"><div style="margin-left:25px;">Work In Progress </div><div style="margin-left:25px;"> <small> ajouté : <p>compatibilité Firefox / IE</p></small> </div></a>
      </div>
    </header>
    <ul id="nav"><!--
        --><li><a href="deschampsberger.html">Côté papa</a></li><!--
        --><li><a href="tripard.html">Côté maman</a></li><!--
        --><li><a href="add_personne.html">Ajout d'une personne</a></li><!--
        --><li><a href="cartographie.html">Cartographie</a></li><!--
        --><li><a href="village.html">Montfort</a></li>
    </ul>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
            <div id="titre"></div>
            <div id="chart" style="overflow-x:scroll"></div>
        </section>

        <aside id="sidebar">
            <div id="RecherchePersonne"></div>
        </aside>
      </div>
    </div>

    <script type="text/javascript">     // Compatibilité FF
    if (!Array.prototype.find) {
        Array.prototype.find = function (callback, thisArg) {
            "use strict";
            var arr = this,
            arrLen = arr.length,
            i;
            for (i = 0; i < arrLen; i += 1) {
                if (callback.call(thisArg, arr[i], i, arr)) {
                    return arr[i];
                }
            }
            return undefined;
        };
    }
    if (!String.prototype.includes) {
        String.prototype.includes = function() {
            'use strict';
            return String.prototype.indexOf.apply(this, arguments) !== -1;
        };
    }
    </script>
    
    
    <script type="text/javascript">
        /**
         * Initialize tree chart object and data loading.
         * @param {Object} d3Object Object for d3, injection used for testing.
         */
        var treeChart = function(d3Object) {
          this.d3 = d3Object;
          // Initialize the direction texts.
          this.directions = ['upward', 'downward'];
        };

        /**
         * Set variable and draw chart.
         */
        treeChart.prototype.drawChart = function() {
          // First get tree data for both directions.
          this.treeData = {};
          var self = this;
          d3.json('raw_all_tree_data.json', function(error, allData) {
            self.directions.forEach(function(direction) {
              self.treeData[direction] = allData[direction];
            });
            self.graphTree(self.getTreeConfig());
          });
        };

        /**
         * Get tree dimension configuration.
         * @return {Object} treeConfig Object containing tree dimension size
         *     and central point location.
         */
        treeChart.prototype.getTreeConfig = function() {
          var treeConfig = {'margin': {'top': 10, 'right': 5, 'bottom': 0, 'left': 30}}
          // This will be the maximum dimensions
          treeConfig.chartWidth = (960 - treeConfig.margin.right -
              treeConfig.margin.left);
          treeConfig.chartHeight = (500 - treeConfig.margin.top -
              treeConfig.margin.bottom);
          treeConfig.centralHeight = treeConfig.chartHeight / 2;
          treeConfig.centralWidth = treeConfig.chartWidth / 2;
          treeConfig.linkLength = 100;
          treeConfig.duration = 200;
          return treeConfig;
        };

        /**
         * Graph tree based on the tree config.
         * @param {Object} config Object for chart dimension and central location.
         */

        treeChart.prototype.graphTree = function(config) {
          var self = this;
          var d3 = this.d3;
          var linkLength = config.linkLength;
          var duration = config.duration;
          // id is used to name all the nodes;
          var id = 0;
          var diagonal = d3.svg.diagonal()
              .projection(function(d) {return [d.x, d.y]; });
          var zoom = d3.behavior.zoom()
              .scaleExtent([0.1, 2])
              .on('zoom', redraw);
          var svg = d3.select('body')
              .append('svg')
              .attr('width',
                    config.chartWidth + config.margin.right + config.margin.left)
              .attr('height',
                    config.chartHeight + config.margin.top + config.margin.bottom)
              .on('mousedown', disableRightClick)
              .call(zoom)
              .on('dblclick.zoom', null);
          var treeG = svg.append('g')
              .attr('transform',
              'translate(' + config.margin.left + ',' + config.margin.top + ')');
          treeG.append('text').text('D3 Development Dependency')
              .attr('class', 'centralText')
              .attr('x', config.centralWidth)
              .attr('y', config.centralHeight + 5)
              .attr('text-anchor', 'middle');
          // Initialize the tree nodes and update chart.
          for (var d in this.directions) {
            var direction = this.directions[d];
            var data = self.treeData[direction];
            data.x0 = config.centralWidth;
            data.y0 = config.centralHeight;
            // Hide all children nodes other than direct generation.
            data.children.forEach(collapse);
            update(data, data, treeG);
          }

          /**
           * Update nodes and links based on direction data.
           * @param {Object} source Object for current chart distribution to identify
           *    where the children nodes will branch from.
           * @param {Object} originalData Original data object to get configurations.
           * @param {Object} g Handle to svg.g.
           */
          function update(source, originalData, g) {
            // Set up the upward vs downward separation.
            var direction = originalData['direction'];
            var forUpward = direction == 'upward';
            var node_class = direction + 'Node';
            var link_class = direction + 'Link';
            var downwardSign = (forUpward) ? -1 : 1;
            var nodeColor = (forUpward) ? '#37592b' : '#8b4513';
            // Reset tree layout based on direction, since the downward chart has
            // way too many nodes to fit in the screen, while we want a symmetric
            // view for upward chart.
            var nodeSpace = 50;
            var tree = d3.layout.tree().sort(sortByDate).nodeSize([nodeSpace, 0]);
            if (forUpward) {
              tree.size([config.chartWidth, config.chartHeight]);
            }
            var nodes = tree.nodes(originalData);
            var links = tree.links(nodes);
            // Offset x-position for downward to view the left most record.
            var offsetX = 0;
            if (!forUpward) {
              var childrenNodes = originalData[
                  (originalData.children) ? 'children' : '_children'];
              offsetX = d3.min([childrenNodes[0].x, 0]);
            }
            // Normalize for fixed-depth.
            nodes.forEach(function(d) {
              d.y = downwardSign * (d.depth * linkLength) + config.centralHeight;
              d.x = d.x - offsetX;
              // Position for origin node.
              if (d.name == 'origin') {
                d.x = config.centralWidth;
                d.y += downwardSign * 25;
              }
            });

            // Update the node.
            var node = g.selectAll('g.' + node_class)
                .data(nodes, function(d) {return d.id || (d.id = ++id); });
            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append('g')
                .attr('class', node_class)
                .attr('transform', function(d) {
                  return 'translate(' + source.x0 + ',' + source.y0 + ')'; })
                .style('cursor', function(d) {
                  return (d.children || d._children) ? 'pointer' : '';})
                .on('click', click);
            nodeEnter.append('circle')
                .attr('r', 1e-6);
            // Add Text stylings for node main texts
            nodeEnter.append('text')
                .attr('x', function(d) {
                  return forUpward ? -10 : 10;})
                .attr('dy', '.35em')
                .attr('text-anchor', function(d) {
                  return forUpward ? 'end' : 'start';})
                .text(function(d) {
                  // Text for origin node.
                  if (d.name == 'origin') {
                    return ((forUpward) ?
                        'Dependency of D3' :
                        'Files dependent on D3'
                        ) + ' [Click to fold/expand all]';
                  }
                  // Text for summary nodes.
                  if (d.repeated) {
                    return '[Recurring] ' + d.name;
                  }
                  return d.name; })
                .style('fill-opacity', 1e-6)
                .style({'fill': function(d) {
                  if (d.name == 'origin') {return nodeColor;}
                }})
                .attr('transform', function(d) {
                  if (d.name != 'origin') {return 'rotate(-20)';}
                })
                  ;

            // Transition nodes to their new position.
            var nodeUpdate = node.transition()
                .duration(duration)
                .attr('transform', function(d) {
                  return 'translate(' + d.x + ',' + d.y + ')'; });
            nodeUpdate.select('circle')
                .attr('r', 6)
                .style('fill', function(d) {
                  if (d._children || d.children) {return nodeColor;}
                })
                .style('fill-opacity', function(d) {
                  if (d.children) {return 0.35;}
                })
                // Setting summary node style as class as mass style setting is
                // not compatible to circles.
                .style('stroke-width', function(d) {
                  if (d.repeated) {return 5;}
                });

            nodeUpdate.select('text').style('fill-opacity', 1);

            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr('transform', function(d) {
                  return 'translate(' + source.x + ',' + source.y + ')'; })
                .remove();
            nodeExit.select('circle')
                .attr('r', 1e-6);
            nodeExit.select('text')
                .style('fill-opacity', 1e-6);

            // Update the links.
            var link = g.selectAll('path.' + link_class)
                .data(links, function(d) { return d.target.id; });

            // Enter any new links at the parent's previous position.
            link.enter().insert('path', 'g')
                .attr('class', link_class)
                .attr('d', function(d) {
                  var o = {x: source.x0, y: source.y0};
                  return diagonal({source: o, target: o});
                });
            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr('d', diagonal);
            // Transition exiting nodes to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr('d', function(d) {
                  var o = {x: source.x, y: source.y};
                  return diagonal({source: o, target: o});
                })
                .remove();
            // Stash the old positions for transition.
            nodes.forEach(function(d) {
              d.x0 = d.x;
              d.y0 = d.y;
            });

            /**
             * Tree function to toggle on click.
             * @param {Object} d data object for D3 use.
             */
            function click(d) {
              if (d.children) {
                d._children = d.children;
                d.children = null;
              }else {
                d.children = d._children;
                d._children = null;
                // expand all if it's the first node
                if (d.name == 'origin') {d.children.forEach(expand);}
              }
              update(d, originalData, g);
            }
          }
          // Collapse and Expand can be modified to include touched nodes.
          /**
           * Tree function to expand all nodes.
           * @param {Object} d data object for D3 use.
           */
          function expand(d) {
            if (d._children) {
              d.children = d._children;
              d.children.forEach(expand);
              d._children = null;
            }
          }

          /**
           * Tree function to collapse children nodes.
           * @param {Object} d data object for D3 use.
           */
          function collapse(d) {
            if (d.children && d.children.length != 0) {
              d._children = d.children;
              d._children.forEach(collapse);
              d.children = null;
            }
          }

          /**
           * Tree function to redraw and zoom.
           */
          function redraw() {
            treeG.attr('transform', 'translate(' + d3.event.translate + ')' +
                ' scale(' + d3.event.scale + ')');
          }
          /**
           * Tree functions to disable right click.
           */
          function disableRightClick() {
            // stop zoom
            if (d3.event.button == 2) {
              console.log('No right click allowed');
              d3.event.stopImmediatePropagation();
            }
          }

          /**
           * Tree sort function to sort and arrange nodes.
           * @param {Object} a First element to compare.
           * @param {Object} b Second element to compare.
           * @return {Boolean} boolean indicating the predicate outcome.
           */
          function sortByDate(a, b) {
            // Compare the individuals based on participation date
            //(no need to compare when there is only 1 summary)
            var aNum = a.name.substr(a.name.lastIndexOf('(') + 1, 4);
            var bNum = b.name.substr(b.name.lastIndexOf('(') + 1, 4);
            // Sort by date, name, id.
            return d3.ascending(aNum, bNum) ||
                d3.ascending(a.name, b.name) ||
                d3.ascending(a.id, b.id);
          }
        };

        var d3GenerationChart = new treeChart(d3);
        d3GenerationChart.drawChart();
    
    </script>
    
    <script type="text/javascript">

    'use strict';

    var svg, tooltip, biHiSankey, path, defs, colorScale, highlightColorScale, isTransitioning;


    function trouverNodes(flagRecherche,elementsRecherches){
        var noeuds = [];
        var sql_statement = "SELECT * FROM nodes WHERE arbre = '1' OR arbre = '2'";
        if (flagRecherche == 1){
            // Dans ce cas, on ajoute une clause WHERE à la recherche
            sql_statement += " AND WHERE ";
            for (var el of elementsRecherches){
                sql_statement += "own_id = '" + el.id + "' OR ";
            }
            sql_statement = sql_statement.substring(0,sql_statement.length - 4);
            //alert("flag-- " + sql_statement);
        }
        $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
            if (data_json.rows.length == 0){
                // Il n'y a personne dans la table
                alert("Il n'y a pas encore de personne dans cet arbre !");
            }
            else if (data_json.rows.length > 0){
                    // Pour chaque ligne, on vérifie
                    for (var r of data_json.rows){
                        noeuds.push({"id":r.own_id,"parent":null,"nom":r.nom,"prenom":r.prenom,"mere":r.mother_id,"pere":r.father_id,"genre":r.genre,"arbre":r.arbre});
                    }
            }
        });
        return noeuds;
    }
    
    /**
    On recherche la plus vieille personne de l'arbre : C'est celle qui n'a ni pere ni mere
    **/
    function jeSuisLePlusVieux(){
        var noeuds = [];
        var sql_statement = "SELECT * FROM nodes WHERE father_id IS NULL AND mother_id IS NULL AND (arbre = '1' OR arbre = '2')";
        $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
            if (data_json.rows.length == 0){
                // Il n'y a personne dans la table
                alert("Il n'y a pas encore de personne dans cet arbre !");
            }
            else if (data_json.rows.length > 0){
                    // Pour chaque ligne, on vérifie
                    for (var r of data_json.rows){
                        noeuds.push({"id":r.own_id,"parent":null,"nom":r.nom,"prenom":r.prenom,"mere":r.mother_id,"pere":r.father_id,"genre":r.genre,"arbre":r.arbre});
                    }
            }
        });
        return noeuds;
    }
    
    /**On récupère les noeuds, puis on lance le dessin de l'arbre
        flagRecherche = 0 : pas de choix de personne à rechercher, 1 : on recherche l'arbre d'une personne en particulier
        elementsRecherches : tableau des personnes à rechercher le cas échéant
    **/
    function populateNode(flagRecherche,elementsRecherches){
        // On récupère la personne la plus ancienne de l'arbre : 
        var oldestPers = jeSuisLePlusVieux();
        
        // Ensuite, on recherche ses enfants
        
        var sql_statement = "SELECT * FROM nodes WHERE arbre = '1' OR arbre = '2'";
        
        $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
            if (data_json.rows.length == 0){
                // Il n'y a personne dans la table
                document.getElementById('titre').innerHTML = "Il n'y a pas encore de personne dans cet arbre !";
            }
            else if (data_json.rows.length > 0){
                    // Pour chaque ligne, on l'ajoute au tableau des noeuds. 
                    // Et on formatte le tableau pour qu'il soit exploitable par D3
                    var nodes, links, liste_couple;
                    nodes = [];
                    links = [];
                    liste_couple = [];
                    for (var r of data_json.rows){
                        // On remplit les personnes
                        nodes.push({"type":r.genre,"id":r.own_id,"parent":null,"name":r.nom,"prenom":r.prenom,"f_id":r.father_id,"m_id":r.mother_id,"c_id":r.couple_id,"dBirth":r.date_naissance,"dDie":r.date_deces,"dMar":r.date_mariage,"job":r.profession,"comm":r.commentaire,"arbre":r.arbre,"adr_photo":r.adr_photo});
                        // Si 1 des 2 parents est en couple, on ajoute un noeud
                        if ((r.couple_id != null && r.couple_id != "null")){
                            var isinliste = 0;
                            for (var lc of liste_couple){
                                if (lc.id_c == r.own_id){
                                    // Si l'id est déjà dans cette liste, on ne l'ajoute pas
                                    isinliste = 1;
                                }
                            }
                            if (isinliste == 0){
                                //var Pere = NoeudsBase.find(function(a){return a.id == r.father_id});
                                var homme = NoeudsBase.find(function(a){return a.id == r.own_id && r.genre == "M"});
                                var saFemme;
                                if (homme){
                                    nodes.push({"type":"couple","id":"c_"+r.couple_id,"parent":null,"name":homme.nom,"prenom":homme.prenom,"id_homme":r.own_id,"id_femme":r.couple_id,"dMar":r.date_mariage,"arbre":r.arbre});
                                    liste_couple.push({"id_c":r.couple_id,"id_homme":r.own_id});
                                }
                            }
                        }
                        // On calcul les liens 
                        var pereExiste = NoeudsBase.find(function(a){return a.id == r.father_id});
                        var mereExiste = NoeudsBase.find(function(a){return a.id == r.mother_id});

                        if (r.father_id == null || r.father_id == " " || r.father_id == "null" || typeof(pereExiste) == 'undefined'){}
                        else {
                            links.push({"source":r.father_id,"target":r.own_id,"value":1});
                            }
                        if (r.mother_id == null || r.mother_id == " " || r.mother_id == "null"  || typeof(mereExiste) == 'undefined'){}
                        else {
                            links.push({"source":r.mother_id,"target":r.own_id,"value":1});
                        }
                    }
                    // Une fois les nodes remplis, on ajoute "parent" des noeuds des personnes en couple : 
                    for (var p of nodes){
                        for (var lc of liste_couple){
                            if (p.id == lc.id_c || p.id == lc.id_homme){
                                p.parent = "c_"+lc.id_c;
                            }
                        }
                    }
            }
            
            //return nodes;
            //return({nodes,links});
            if (flagRecherche == 1 && elementsRecherches.length == 0){
            }
            else {
                drawTree(nodes,links);
            }
            
            if (flagRecherche != 0){
                return [nodes,links];
            }
            });
    }

    var formatNumber = function (d) {
      var numberFormat = d3.format(",.0f"); // zero decimal places
      return " - " + numberFormat(d);
    },

    formatFlow = function (d) {
      var flowFormat = d3.format(",.0f"); // zero decimal places with sign
      return flowFormat(Math.abs(d));
    },

    
    </script>
  
  </body>
</html>
