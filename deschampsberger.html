<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <script src="http://libs.cartocdn.com/cartodb.js/v3/3.15/cartodb.js" type="text/javascript"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" type="text/css" href="stylesheets/timeline.css">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link href="http://code.jquery.com/ui/1.11.4/themes/ui-lightness/jquery-ui.css" rel="stylesheet">
    <script type="text/javascript" src="javascripts/timeline.js"></script>
    
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Travaux Carto</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Travaux Carto</h1>
        <h2 style="text-align:right;">et un peu de généalogie</h2>
        <a class="WIP" style="width:250px;height: 140px;"><div style="margin-left:25px;">Work In Progress </div><div style="margin-left:25px;"> <small> ajouté : <p>carto historique</p></small> </div></a>
      </div>
    </header>
    <ul id="nav">
        <li><a href="deschampsberger.html">Illustrations</a>
            <ul>
                <li><a href="index.html">timeline</a></li>
                <li><a href="deschampsberger.html">arbre</a></li>
            </ul>
        </li>
        <li><a href="add_personne.html">Ajout d'une personne</a></li>
        <li><a href="cartographie.html">Cartographie</a></li>
        <li><a href="village.html">Montfort</a></li>
    </ul>
    <div class="content-tooltip">
        <img id="helper" src="./images/help-icon.png" width="80px" height="80px" style="float:left" onmouseover="showHelp()" onmouseout="hideHelp()"></img>
        <div id="help" style="display:none; position:absolute; left:90px;border-left:solid 1px black;border-bottom:solid 1px black;background-color:aliceblue">
            <h3>Module d'aide</h3>
            <h4>Zoomez dans le graph avec la molette de votre souris</h4>
            <h4>Déplacez vous dans le graph en faisant un clique gauche tout en déplaçant votre souris</h4>
            <h4>Consultez les info de chaque personne en gardant la souris sur son image</h4>
        </div>
    </div>
    <div id="content-wrapper">
        <div class="inner clearfix">
        <!--<img src="./images/help-icon.png" width="80px" height="80px" style="float:left"></img>-->
            <section id="main-content">
                <div id="chart" style=""></div>
            </section>
    
            <aside id="sidebar">
                <div id="RecherchePersonne"></div>
                <div id="sideTooltip"></div>
            </aside>
          </div>
    </div>
    
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-86030173-1', 'auto');
      ga('send', 'pageview');
    </script>
    
    <script type="text/javascript">     //Helper
        function showHelp(){
            console.log("help!");
            $(help).show();
        }
        function hideHelp(){
            console.log("help!");
            $(help).hide();
        }
    </script>
    
    <script type="text/javascript">     // Compatibilité FF
    if (!Array.prototype.find) {
        Array.prototype.find = function (callback, thisArg) {
            "use strict";
            var arr = this,
            arrLen = arr.length,
            i;
            for (i = 0; i < arrLen; i += 1) {
                if (callback.call(thisArg, arr[i], i, arr)) {
                    return arr[i];
                }
            }
            return undefined;
        };
    }
    if (!String.prototype.includes) {
        String.prototype.includes = function() {
            'use strict';
            return String.prototype.indexOf.apply(this, arguments) !== -1;
        };
    }
    </script>
    
    <script type="text/javascript">     // Définition de la fenêtre de recherche
    
        var globalNodes = trouverNodesAll();
        var noeudsExistants = globalNodes[0];
        var availableNames = globalNodes[1];
        
        // Barre de recherche de personne : 
        $(RecherchePersonne).append('<fieldset style="border:solid 1px black;width:390px"><legend>Recherche</legend><div id="recherche" style="margin:10px;">Nom de la personne : <input type="text" class="txt_ajt" name="txt_old_nom" id="txt_old_nom_auto" value="" onblur="remplirFamille(value);" autocomplete="on"><FORM NAME="Choix_genre_search" style="display: initial;margin-left: 10px;"><SELECT id="genres_search" NAME="genre" onchange="remplirFamille($(txt_old_nom_auto).val())"><option value="M">Homme</option><option value="F">Femme</option></SELECT></FORM><FORM NAME="Choix_old_prenom" style="display: initial;margin-left: 10px;"><SELECT id="liste_old_prenom" NAME="liste_old_prenom" style="margin-top:20px;margin-left:120px;"></SELECT></FORM><a id="focus_p" class="button_small" onclick="focusPersonne($(liste_old_prenom).val());";>Centrer</a><a id="reinit" class="button_small" style="display:none;" onclick="hideObject(reinit);showObject(focus_p);reinitialiser();";>Réinitialiser</a></div></fieldset>');
            
        $(txt_old_nom_auto).autocomplete({
          source: availableNames,
          minChars: 1,
          select: function (event, ui) {
                var value = ui.item.value;
                remplirFamille(value);
        }
        });
        
        function trouverNodesAll(){
            var noeuds = [];
            var aNames = [];
            var sql_statement = "SELECT * FROM nodes WHERE arbre = '1' OR arbre = '2'";
            $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
                if (data_json.rows.length == 0){
                    // Il n'y a personne dans la table
                    alert("Il n'y a pas encore de personne dans cet arbre !");
                }
                else if (data_json.rows.length > 0){
                        // Pour chaque ligne, on vérifie
                        for (var r of data_json.rows){
                            noeuds.push({"id":r.own_id,"parent":null,"nom":r.nom,"prenom":r.prenom,"mere":r.mother_id,"pere":r.father_id,"genre":r.genre,"couple":r.couple_id,"job":r.profession,"date_birth":formatDate(r.date_naissance),"date_die":formatDate(r.date_deces),"date_mariage":formatDate(r.date_mariage),"geom":r.the_geom, "arbre":r.arbre});
                            if (aNames.find(function(a){return a == r.nom;})){}
                            else {aNames.push(r.nom);}
                        }
                }
            });
            return [noeuds,aNames];
        }
        
        function formatDate(date){
            var dateFormatee = "";
            if (date == null ||date == "null" || date == "") return "null";
            else {dateFormatee = date.substring(8,10) + " " + getMonth(date.substring(5,7)) + " " + date.substring(0,4);
            return dateFormatee;
            }
        }
            
        function getMonth(mm){
            switch(mm)
            {
                case "01":return "Janvier";
                case "02":return "Fevrier";
                case "03":return "Mars";
                case "04":return "Avril";
                case "05":return "Mai";
                case "06":return "Juin";
                case "07":return "Juillet";
                case "08":return "Aout";
                case "09":return "Septembre";
                case "10":return "Octobre";
                case "11":return "Novembre";
                case "12":return "Decembre";
            }
        }
        
    </script>
    
    <script type="text/javascript">
    /**
        BUG CONNUS : 
            - le pliage/dépliage des descendants ne fonctionne plus
            - la selection d'un noeud fait perdre sa photo
    */
    function isParentCelib(node){
        var nodes = biHiSankey.nodes();
        var isInCouple = 0;
        var isParent = 0;
        nodes.forEach(function (n) {
            if (n.c_id == node.source.id){
                isInCouple += 1; // Si la personne est en couple avec le noeud, c'est mort
            }    
        });
        nodes.forEach(function(n){
            if (n.f_id == node.source.id || n.m_id == node.source.id){
                isParent += 1;    
            }
        });
        if (isInCouple == 0&& isParent>0){return true;}
        else {return false;}
    }
    
    function ascendingXPosition(a, b) {
                return a.x - b.x;
              }
              
    function ascendingYPosition(a, b) {
        return a.y - b.y;
      }
    
    Array.prototype.max = function() {
        var max = 0;
        for (var el of this){
            if (el == 'undefined' || el == NaN){
            }
            else {
                if (el > max){
                    max = el;
                }
            }
        }
      return max;
    };          
    d3.biHiSankey = function () {
      //"use strict";

      var biHiSankey = {},
        nodeWidth = 18,
        nodeSpacing = 50,
        linkSpacing = 1,
        arrowheadScaleFactor = 0.5, // Specifies the proportion of a link's stroke width to be allowed for the marker at the end of the link.
        size = [5, 1], // default to one pixel by one pixel
        nodes = [],
        nodeMap = {},
        parentNodes = [],
        leafNodes = [],
        links = [],
        xScaleFactor = 5,
        yScaleFactor = 1,
        defaultLinkCurvature = 0.5;

      function center(node) {
        return node.y + node.height / 5;
        // return 0;
      }

      function value(link) {
        return link.value;
      }

      function initializeNodeArrayProperties(node) {
        node.sourceLinks = [];
        node.rightLinks = [];
        node.targetLinks = [];
        node.leftLinks = [];
        node.connectedNodes = [];
        node.children = [];
        node.ancestors = [];
      }
      
      

    
      // generates the nodeMap {"1": <node1>, "2": <node2>}
      // and initializes the array properties of each node
      function initializeNodeMap() {
        nodes.forEach(function (node) {
          nodeMap[node.id] = node;
          initializeNodeArrayProperties(node);
        });
      }

      function computeLeafNodes() {
        leafNodes = nodes.filter(function (node) {
          return !node.children.length;
        });
      }

      function computeParentNodes() {
        parentNodes = nodes.filter(function (node) {
          return node.children.length;
        });
      }

      function addAncestorsToChildren(node) {
        node.children.forEach(function (child) {
          child.ancestors = child.ancestors.concat(this.ancestors.concat([this]));
          addAncestorsToChildren(child);
        }, node);
      }
      
      // generate hierarchical connections between parent and child nodes
      function computeNodeHierarchy() {
        var parent,
            rootNodes = [];

        nodes.forEach(function (node) {
          parent = nodeMap[node.parent];
          if (parent) {
            node.parent = parent;
            parent.children.push(node);
          } else {
            node.parent = null;
            rootNodes.push(node);
          }
        });

        computeLeafNodes();
        computeParentNodes();

        rootNodes.forEach(function (rNode) {
          addAncestorsToChildren(rNode);
        });
      }

      // Populate the sourceLinks and targetLinks for each node.
      function computeNodeLinks() {
        var sourceNode, targetNode;
        links.forEach(function (link) {                         // Gérer le cas des liens entre personnes d'un couple
                if (typeof(link) != 'undefined'){
                    sourceNode = nodeMap[link.source] || link.source;
                    targetNode = nodeMap[link.target] || link.target;
                    link.id = link.source + '-' + link.target;
                    link.source = sourceNode;
                    link.target = targetNode;
                    sourceNode.sourceLinks.push(link);
                    targetNode.targetLinks.push(link);
              }
            });
      }

      function visible(linkCollection) {
        return linkCollection.filter(function (link) {
          return (link.source.state === "collapsed" || link.target.state === "expanded")       // Gestion de l'affichage des liens pour ne pas voir les liens parents->enfants autre que ceux passant par le couple
                && ((!link.source.id.includes("c_") && link.target.id.includes("c_") && link.source.x == link.target.x) 
                    || (link.source.id.includes("c_") && !link.target.id.includes("c_"))
                    || (isParentCelib(link) && !link.target.id.includes("c_"))      // Cas des parents célibataires
                    );
        });
      }

      // When child nodes are collapsed into their parents (or higher ancestors)
      // the links between the child nodes should be represented by links
      // between the containing ancestors. This function adds those extra links.
      function computeAncestorLinks() {
        // Leaf nodes are never parents of other nodes
        // Duplicate source and target links between a leaf node and another leaf node
        // and add to the leaf nodes' parents
        leafNodes.forEach(function (leafNode) {
          leafNode.sourceLinks.forEach(function (sourceLink) {
            var ancestorTargets,
            target = sourceLink.target;
            if (leafNodes.indexOf(target) >= 0) {
              ancestorTargets = target.ancestors.filter(function (tAncestor) {
                return leafNode.ancestors.indexOf(tAncestor) < 0;
              });
              ancestorTargets.forEach(function (ancestorTarget) {
                var ancestorLink = { source: leafNode,
                                    target: ancestorTarget,
                                    value: sourceLink.value,
                                    id: leafNode.id + "-" + ancestorTarget.id };

                leafNode.sourceLinks.push(ancestorLink);
                ancestorTarget.targetLinks.push(ancestorLink);
                links.push(ancestorLink);
              });
            }
          });

          leafNode.targetLinks.forEach(function (targetLink) {
            var ancestorSources, source = targetLink.source;
            if (leafNodes.indexOf(source) >= 0) {
              ancestorSources = source.ancestors.filter(function (sAncestor) {
                return leafNode.ancestors.indexOf(sAncestor) < 0;
              });
              ancestorSources.forEach(function (ancestorSource) {
                var ancestorLink = { source: ancestorSource,
                                    target: leafNode,
                                    value: targetLink.value,
                                    id: ancestorSource.id + "-" + leafNode.id };
                ancestorSource.sourceLinks.push(ancestorLink);
                leafNode.targetLinks.push(ancestorLink);
                links.push(ancestorLink);
              });
            }
          });
        });

        // Add links between parents (for when both parents are in collapsed state)
        parentNodes.forEach(function (parentNode) {
          parentNode.sourceLinks.forEach(function (sourceLink) {
            var ancestorTargets, target = sourceLink.target;
            if (leafNodes.indexOf(target) >= 0) {
              ancestorTargets = target.ancestors.filter(function (tAncestor) {
                return parentNode.ancestors.indexOf(tAncestor) < 0;
              });
              ancestorTargets.forEach(function (ancestorTarget) {
                var ancestorLink = { source: parentNode,
                                    target: ancestorTarget,
                                    value: sourceLink.value,
                                    id: parentNode.id + " -> " + ancestorTarget.id };

                parentNode.sourceLinks.push(ancestorLink);
                ancestorTarget.targetLinks.push(ancestorLink);
                links.push(ancestorLink);
              });
            }
          });
        });
      }

      // To reduce clutter in the diagram merge links that are from the                  
      // same source to the same target by creating a new link                           
      // with a value equal to the sum of the values of the merged links                 
      function mergeLinks() {                                                            
        var linkGroups = d3.nest()                                                       
          .key(function (link) { return link.source.id + "->" + link.target.id; })       
          .entries(links)                                                                
          .map(function (object) { return object.values; });
      }

      // Calcul la hauteur de chaque noeuds
      function nodeHeight(sideLinks) {
        var spacing = Math.max(sideLinks.length - 1, 0) * linkSpacing,
            scaledValueSum = (d3.sum(sideLinks, value) * yScaleFactor) / 6;
        return scaledValueSum + spacing;
      }

      // Compute the value of each node by summing the associated links.
      // Compute the number of spaces between the links
      // Compute the number of source links for later decrementing
      function computeNodeValues() {
        nodes.forEach(function (node) {
          node.value = Math.max(                // node.value modifie la largeur du lien
            d3.sum(node.leftLinks, value),
            d3.sum(node.rightLinks, value)
          );
          node.netFlow = 1;
          node.height = Math.max(nodeHeight(visible(node.leftLinks)), nodeHeight(visible(node.rightLinks)));
          //node.linkSpaceCount = Math.max(Math.max(node.leftLinks.length, node.rightLinks.length) - 1, 0);
          node.linkSpaceCount = 1;
        });
      }

      function computeConnectedNodes() {
        var sourceNode, targetNode;
        links.forEach(function (link) {
            sourceNode = link.source;
            targetNode = link.target;
            sourceNode.connectedNodes.push(targetNode);
            targetNode.connectedNodes.push(sourceNode);
          });
      }

      function sourceAndTargetNodesWithSameX() {            // Dans une même génération donc
        var nodeArray = [];
        links.filter(function (link) {
          return link.target.x === link.source.x;
        }).forEach(function (link) {
          if (nodeArray.indexOf(link.target) < 0) {
            nodeArray.push(link.target);
          }
        });
        return nodeArray;
      }

      function compressInXDirection() {
        var connectedNodesXPositions,
            nodesByXPosition = d3.nest()
              .key(function (node) { return node.x; })
              .sortKeys(d3.ascending)
              .entries(nodes)
              .map(function (object) { return object.values; });

        nodesByXPosition.forEach(function (xnodes) {
          xnodes.forEach(function (node) {
            connectedNodesXPositions = node.connectedNodes.map(function (connectedNode) {
              return connectedNode.x;
            });
            // keep decrementing the x value of the node
            // unless it would have the same x value as one of its source or target nodes
            // or node.x is already 0
            while (node.x > 0 && connectedNodesXPositions.indexOf(node.x - 1) < 0) {
              node.x -= 1;
            }
            node.x = node.x;
          });
        });
      }

      function scaleNodeXPositions() {
        var minX = d3.min(nodes, function (node) { return node.x; }),
            maxX = d3.max(nodes, function (node) { return node.x; }); // - minX;
        xScaleFactor = (size[0] - nodeWidth) / maxX;

        nodes.forEach(function (node) {
          node.x *= xScaleFactor;
        });
      }

      function computeNodeXPositions() {
      // 1ère exposition des X
        var remainingNodes = nodes,
            nextNodes,
            x = 0,
            addToNextNodes = function (link) {
              if (nextNodes.indexOf(link.target) < 0 && link.target.x === this.x) {
                nextNodes.push(link.target);
              }
            },
            setValues = function (node) {
                node.x = x;
                node.width = nodeWidth;
                if (node.sourceLinks){          // on teste l'existence de sourceNode par rapport aux ajout du filtre ligne 212
                    node.sourceLinks.forEach(addToNextNodes, node);
                }
            };

        while (remainingNodes.length) {
          nextNodes = [];
          remainingNodes.forEach(setValues);
          if (nextNodes.length) {
            remainingNodes = nextNodes;
          } else {
            remainingNodes = sourceAndTargetNodesWithSameX();
          }
          x += 1;
        }

        //compressInXDirection();
        scaleNodeXPositions();
      }

      function computeLeftAndRightLinks() {
        var source, target;
        nodes.forEach(function (node) {
          node.rightLinks = [];
          node.leftLinks = [];
        });
        links.forEach(function (link) {
          source = link.source;
          target = link.target;
          if (source.x < target.x) {
            source.rightLinks.push(link);
            target.leftLinks.push(link);
            link.direction = 1;
          } else {
            source.leftLinks.push(link);
            target.rightLinks.push(link);
            link.direction = -1;
          }
        });
      }

      function adjustTop(adjustment) {
        nodes.forEach(function (node) {
          node.y -= adjustment;
        });
      }
      
      // Calcul de la taille du lien
        function calculateLinkThickness() {
          links.forEach(function (link) {
            link.thickness = link.value * yScaleFactor / 6;

          });
        }

      function computeNodeYPositions(iterations) {
        var minY,
            alpha,
            nodesByXPosition = d3.nest()
              .key(function (node) { return node.x; })
              .sortKeys(d3.ascending)
              .entries(nodes)
              .map(function (object) { return object.values; });

        function calculateYScaleFactor() {
          var linkSpacesCount, nodeValueSum, discretionaryY;
          yScaleFactor = d3.min(nodesByXPosition, function (nodes) {
            linkSpacesCount = d3.sum(nodes, function (node) {
              return node.linkSpaceCount;
            });
            nodeValueSum = d3.sum(nodes, function (node) {return node.value;});
            discretionaryY = (size[1]
                            - (nodes.length - 1) * nodeSpacing
                            - linkSpacesCount * linkSpacing);

            return  discretionaryY / nodeValueSum;
          });

          // Fat links are those with lengths less than about 4 times their heights
          // Fat links don't bend well
          // Test that yScaleFactor is not so big that it causes "fat" links; adjust yScaleFactor accordingly
          links.forEach(function (link) {
            var linkLength = Math.abs(link.source.x - link.target.x),
                linkHeight = link.value * yScaleFactor;
            if (linkLength / linkHeight < 4) {
              yScaleFactor = 0.5 * linkLength / link.value;
            }
          });
        }
                                                                                                         // calcul de la position verticale
        function initializeNodeYPosition() {           

        function ascendingYancPosition(a, b) {
            return a.yAnc - b.yAnc;
          }
        function ascendingYPosition(a, b) {
            return a.y - b.y;
          }
          
          // Retourne les éléments d'unique ID d'une table
          function multiDimensionalUnique(arr) {
            var uniques = [];
            var itemsFound = {};
            for(var i = 0, l = arr.length; i < l; i++) {
                var stringified = JSON.stringify(arr[i].id);
                if(itemsFound[stringified]) { continue; }
                uniques.push(arr[i]);
                itemsFound[stringified] = true;
            }
            return uniques;
        }

        function ascendingNodeXPosition(a, b) {
            return a[0].x - b[0].x;
          }
          
          
        nodesByXPosition.forEach(function (nodes) {
               nodes.forEach(function (node, i) {
                   if (node.x == 0){
                         node.y = i*10;                                                                                // calcul de la position verticale
                         node.heightAllowance = node.value * yScaleFactor + linkSpacing * node.linkSpaceCount;  
                     }
                     else {
                       node.y = 0;
                        //node.heightAllowance = node.value * yScaleFactor + linkSpacing * node.linkSpaceCount;  
                        node.heightAllowance = node.value * yScaleFactor;// + linkSpacing * node.linkSpaceCount;  
                     }
                       //i++;// calcul de la position verticale
                });
            });
            var generation = 0;
            //nodesByXPosition contient un tableau par X, soit un tableau par génération en commençant par les plus jeunes (donc on inverse le tableau pour partir des plus vieux)
            // Il faut qu'on trie les descendants en fonction du y de leur ancetre
            var nodesGenerationXclasses = nodesByXPosition.sort(ascendingNodeXPosition);
            for (var tabGeneration of nodesGenerationXclasses){
                if(generation > 0){
                    // On récupère les ancêtres :
                   var tabYancestors = [];
                   for (var node of tabGeneration){
                       if (node.y == 0 && !node.type.includes("couple")){
                           // on remplit le tableau avec l'id, le y de l'ancetre et le y que l'on calculera
                           // connectedAncetres contient tous les ancetres du noeuds node
                           var connectedAncetres = node.connectedNodes.filter(function (bn){return bn.x < node.x;});
                           if (connectedAncetres.length > 1){
                                // on a donc 2 grands parents : 
                                node.y = (connectedAncetres[0].y + connectedAncetres[1].y)/2;
                           }
                           else if (connectedAncetres.length == 1){
                            // on a qu'un seul grand parent : 
                                node.y = connectedAncetres[0].y;
                           }
                           else {
                            // on a a priori aucun grand parent : 
                                node.y = 'undefined';
                           }
                       }
                   }
                // Pour tous ceux qui ont des ancêtres, on leur donne le yVoulu
                var tabTrieparYAnc = tabYancestors.sort(ascendingYancPosition);
                var i = tabGeneration.max()=='undefined' ? 0:tabGeneration.max()+1;
                for (var node of tabGeneration){
                    var conjoint = tabGeneration.find(function(a){return a.c_id == node.id});
                    if (node.y == 'undefined' && conjoint.y != 'undefined'){
                        node.y = conjoint.y;
                    }
                    else if (node.y == 'undefined' && node.id.includes('c_')){
                        node.y = i;
                    }
                }
                
                 //  // On rassemble les couples 
                   var tabHomme = tabGeneration.filter(function (a){return (a.type == "M" && !a.id.includes("c_")) || (a.type == "F" && (a.c_id == "" || a.c_id == "null" ||a.c_id == null))});
                   var tabFemme = tabGeneration.filter(function (a){return a.type == "F" && !a.id.includes("c_")});
                   var tabFinalYClasse = tabHomme.sort(ascendingYPosition);
                   // On va ajouter les femmes au tableau des hommes :
                   for (var nodeH of tabFinalYClasse){
                        if ((nodeH.c_id != null && nodeH.c_id != "null" && nodeH.c_id != "")){
                            var saFemme = tabFemme.find(function(a){return a.c_id == nodeH.id});
                            // on ajoute à l'index voulu :
                            if (saFemme != 'undefined' && saFemme != undefined){
                                tabFinalYClasse.splice(tabFinalYClasse.indexOf(nodeH)+1, 0, saFemme);
                            }
                        }
                   }
                   // Maintenant qu'on a un tableau trié, on réassigne les y suivant la position du tableau : 
                   var ajout = 0;
                   for (var n of tabFinalYClasse){
                        //n.y = tabFinalYClasse.indexOf(n);
                        n.y = ajout;
                        ajout++;
                   }
                   // On vérifie qu'on a oublié personne :
                   for (var node of tabGeneration){
                        if(tabFinalYClasse.find(function (a){return a === node;})){
                            // Pas besoin de l'ajouter à nouveau
                        }
                        else {tabFinalYClasse.push(node);}
                   }
                    tabGeneration = tabFinalYClasse;
                    
                 // Il faut itérer sur les couples pour moyenner leurs Y afin qu'ils se trouvent à la même place
                   var tabCouple = tabGeneration.filter(function (a){return a.id.includes("c_")}); // On ne gère que les points "Couple"
                   for (var c of tabCouple){
                       var homme = tabGeneration.find(function (a){return a.id == c.id_homme});
                       var femme = tabGeneration.find(function (a){return a.id == c.id_femme});
                       c.y = (homme.y + femme.y) / 2;
                       c.x = homme.x;
                   }
                }
                if (generation == 0){
                    // On rassemble les couples pour la 1ère génération
                    var tabHomme = tabGeneration.filter(function (a){return a.type == "M"  && !a.id.includes("c_")});
                    var tabFemme = tabGeneration.filter(function (a){return a.type == "F"  && !a.id.includes("c_")});
                    tabHomme.forEach(function (nodeH, h) {
                        nodeH.y = h;
                        //nodeH.x = generation;
                        if ((nodeH.c_id != null && nodeH.c_id != "null")){
                            var saFemme = tabFemme.find(function(a){return a.c_id == nodeH.id});
                            saFemme.y = h + 1;
                            //saFemme.x = generation;
                            h ++;
                        }
                    });
                    // Il faut itérer sur les couples pour moyenner leurs Y afin qu'ils se trouvent à la même place
                    var tabCouple = tabGeneration.filter(function (a){return a.id.includes("c_")});
                    for (var c of tabCouple){
                        var homme = tabGeneration.find(function (a){return a.id == c.id_homme});
                        var femme = tabGeneration.find(function (a){return a.id == c.id_femme});
                        c.y = (homme.y + femme.y) / 2;
                        c.x = homme.x;
                    }
                }
                generation = generation + 1;
            }
            
            // A ce niveau, les gens sont correctement placés sur l'arbre. 
            // Maintenant, nous voulons qu'ils soient le plus possible placé en fonction de leurs ancêtre de manière "droite", "direct", que le tronc soit le plus droit possible
            //1. on cherche la génération comportant le plus d'enfant sans couple
            //2. on recalcule la position des parents et des enfants en fonction de la place des gens sur la génération la plus nombreuse
            var geneLaPlusNombreuse = 0;
            var maxLength = 0;
            for (var i = 0;i<nodesGenerationXclasses.length;i++){
                if (nodesGenerationXclasses[i].length > maxLength){
                    maxLength = nodesGenerationXclasses[i].filter(function(n){return n.type != "couple";}).length;
                    geneLaPlusNombreuse = i;
                }
            }
            
            var tabGenePlusNombreuse = nodesGenerationXclasses[geneLaPlusNombreuse].sort(ascendingYPosition);
            // On commence par traiter les générations plus récentes : 
            var generationN = geneLaPlusNombreuse + 1; // C'est la 1ère génération après la plus nombreuse
            //var generationN = 3; // C'est la 1ère génération après la plus nombreuse
            
            for (var gene = generationN;gene<nodesGenerationXclasses.length;gene++){
            //--Début classement des enfants par parents
            //for (var parent of nodesGenerationXclasses[gene-1]){
            //    //Pour chaque parent, on récupère les enfants : 
            //    var Enfants = nodesGenerationXclasses[gene].filter(function(n){return (n.f_id == parent.id && n.f_id != null)||(n.m_id == parent.id && n.m_id != null)});
            //    for (var e of Enfants){
            //        e.parentID = parent.id;
            //    }
            //}
            //var nodesByParents = d3.nest()      //nodesByParents contient un tableau d'enfants classés par parents
            //  .key(function (node) { return node.parentID; })
            //  .sortKeys(d3.ascending)
            //  .entries(nodesGenerationXclasses[gene])
            //  .map(function (object) { return object.values; });
            //      
            //--Fin classement des enfants par parents
                var tabGene = nodesGenerationXclasses[gene].sort(ascendingYPosition);
                for (var node of tabGene){
                    if (typeof(node.ytraiteok) != 'undefined'){
                    }
                    else {
                        if (node.type != 'couple'){
                            var FreresEtSoeurs = tabGene.filter(function (bn){return ((bn.m_id == node.m_id && bn.m_id != null) || (bn.f_id == node.f_id && bn.f_id != null));});   // Les frères et soeurs des enfants
                            var Parents = nodesGenerationXclasses[gene-1].filter(function (bn){return bn.id == node.m_id || bn.id == node.f_id;}); // gene-1 est la génération la plus nombreuse
                            //FreresEtSoeurs.add(node);
                            if (FreresEtSoeurs.length == 1){ // Le noeud est fils unique
                                var minYParents = d3.min(Parents, function (node) { return node.y; });
                                var maxYParents = d3.max(Parents, function (node) { return node.y; });
                                var meanYParents = (maxYParents + minYParents)/2;
                                var dy = meanYParents - node.y;
                                node.y += dy;
                                node.ytraiteok = 'ok';
                                // On déplace également le couple et le point du couple s'il existe : 
                                var encouple = tabGene.find(function(n){return n.c_id == node.id;});
                                if (typeof(encouple) != 'undefined'){
                                    var nodeCouple = tabGene.find(function(n){return n.id == "c_"+node.id || n.id == "c_"+encouple.id;});
                                    if (typeof(nodeCouple.ytraiteok) == 'undefined'){
                                        nodeCouple.y = dy;
                                        nodeCouple.ytraiteok = 'ok';
                                    }
                                    if (typeof(encouple.ytraiteok) == 'undefined'){
                                        encouple.y = dy;
                                        encouple.ytraiteok = 'ok';
                                    }
                                }
                                for (var autreNoeuds of tabGene.filter(function(n){return typeof(n.ytraiteok) == 'undefined'})){
                                    autreNoeuds.y += dy;
                                }
                            }
                            else if (FreresEtSoeurs.length > 1){  // Le noeud a des frères et soeurs
                                var minYFratrie = d3.min(FreresEtSoeurs, function (node) { return node.y; });
                                var maxYFratrie = d3.max(FreresEtSoeurs, function (node) { return node.y; });
                                var meanYFratrie = (maxYFratrie + minYFratrie)/2;
                                var minYParents = d3.min(Parents, function (node) { return node.y; });
                                var maxYParents = d3.max(Parents, function (node) { return node.y; });
                                var meanYParents = (maxYParents + minYParents)/2;
                                var dy = meanYParents - meanYFratrie;
                                for (var fratrie of FreresEtSoeurs.filter(function(n){return typeof(n.ytraiteok) == 'undefined'})){
                                    fratrie.y += dy;
                                    fratrie.ytraiteok = 'ok';
                                    // On déplace également le couple et le point du couple s'il existe : 
                                    var encouple = tabGene.find(function(n){return n.c_id == fratrie.id;});
                                    if (typeof(encouple) != 'undefined'){
                                        var nodeCouple = tabGene.find(function(n){return n.id == "c_"+fratrie.id || n.id == "c_"+encouple.id;});
                                        if (typeof(nodeCouple.ytraiteok) == 'undefined'){
                                            nodeCouple.y = meanYParents + dy;
                                            nodeCouple.ytraiteok = 'ok';
                                        }
                                        if (typeof(encouple.ytraiteok) == 'undefined'){
                                            encouple.y = meanYParents + dy;
                                            encouple.ytraiteok = 'ok';
                                        }
                                    }
                                }
                                for (var autreNoeuds of tabGene.filter(function(n){return typeof(n.ytraiteok) == 'undefined'})){
                                    autreNoeuds.y += dy;
                                }
                            }
                        }
                    }
                }
            }
            ////Puis les générations plus anciennes, en commençant par leurs parents : 
            var generationN = geneLaPlusNombreuse - 1;
            //for (var gene = generationN;gene>-1;gene--){
            for (var gene = generationN;gene>-1;gene--){
                var tabGene = nodesGenerationXclasses[gene].sort(ascendingYPosition);
                var minYDetermineOK = 0;        // Cette variable nous permet de ne pas nous occuper des personnes dont la position est déjà derrière les y traités
                var oldMinYDetermineOK = 0;
                for (var node of tabGene){
                    if (typeof (node.ytraiteok) == 'undefined'){
                        var Parents = tabGene.filter(function (bn){return bn.c_id == node.id || bn.id == node.id}); //Les max 2 parents à bouger
                        var Descendants = nodesGenerationXclasses[gene+1].filter(function (bn){return bn.m_id == node.id || bn.f_id == node.id;}); //De la génération "enfant"
                        if (Descendants.length == 0){ // Le noeud n'a pas de descendant
                            minYDetermineOK = node.y;
                            node.ytraiteok = 'ok';
                            oldMinYDetermineOK = minYDetermineOK;
                        }
                        else {
                            var minYFratrie = d3.min(Descendants, function (node) { return node.y; });
                            var maxYFratrie = d3.max(Descendants, function (node) { return node.y; });
                            var meanYFratrie = (maxYFratrie + minYFratrie)/2;
                            var minYParents = d3.min(Parents, function (node) { return node.y; });
                            var maxYParents = d3.max(Parents, function (node) { return node.y; });
                            var meanYParents = (maxYParents + minYParents)/2;
                            var dy = meanYFratrie - meanYParents;
                            if (minYParents+dy<minYDetermineOK){    // Si le décalage revient sur des éléments déjà positionné, on ne déplace pas le noeuds, par contre, on replace ses descendants. 
                                for (var parent of Parents){    
                                    parent.ytraiteok = 'ok';
                                    var nodeCouple = tabGene.find(function(n){return n.id == "c_"+Parents[0].id || n.id == "c_"+Parents[1].id;});
                                    nodeCouple.ytraiteok = 'ok';
                                    minYDetermineOK = maxYParents;
                                }
                                var dyDesc = meanYParents - meanYFratrie;
                                var IDdescendantsLarges = [];
                                for (descendant of Descendants){
                                    IDdescendantsLarges.push(descendant.id);
                                    descendant.y += dyDesc;
                                    var encouple = nodesGenerationXclasses[gene+1].find(function(n){return n.c_id == descendant.id || n.id == descendant.c_id;});
                                    if (typeof(encouple) != 'undefined'){ 
                                        encouple.y +=dyDesc;
                                        pointCouple = nodesGenerationXclasses[gene+1].find(function(n){return n.id == "c_"+descendant.id || n.id == "c_"+descendant.c_id;});
                                        pointCouple.y += dyDesc; // point couple
                                        IDdescendantsLarges.push(encouple.id);
                                        IDdescendantsLarges.push(pointCouple.id);
                                    }
                                }
                                // Il faut appliquer ce traitement à tous les noeuds de la géné n+1 qui sont impactés par le déplacement des descendants
                                noeudsImpactes = nodesGenerationXclasses[gene+1].filter(function(n){return n.y > minYFratrie + dyDesc;});
                                //descendantsLarges = nodesGenerationXclasses[gene+1].filter(function (bn){return bn.m_id == node.id || bn.f_id == node.id || bn.c_id == node.id || bn.id == node.c_id || bn.id == "c_" + node.id;})
                                // on retranche les descendants à ce tableau
                                var noeudsImpactesAllege = [];
                                for (no of noeudsImpactes){
                                    if (jQuery.inArray(no.id,IDdescendantsLarges) == -1){
                                        noeudsImpactesAllege.push(no);
                                    }
                                }
                                
                                if (noeudsImpactesAllege.length > 0){
                                    for (descendant of noeudsImpactesAllege){
                                        descendant.y += dyDesc;
                                    }
                                }
                            }
                            else{
                                for (var parent of Parents){
                                    parent.y += dy;
                                    parent.ytraiteok = 'ok';
                                }
                                // On déplace également le point du couple s'il existe : 
                                if (Parents.length > 1){
                                            var nodeCouple = tabGene.find(function(n){return n.id == "c_"+Parents[0].id || n.id == "c_"+Parents[1].id;});
                                            nodeCouple.y = meanYParents + dy;
                                            nodeCouple.ytraiteok = 'ok';
                                }
                            }
                            
                            var rad = tabGene.filter(function(n){return typeof(n.ytraiteok) == 'undefined' && n.y > oldMinYDetermineOK});
                            var radID = [];
                            for (var r of rad){
                                radID.push(r.id);
                            }
                            var coupure = 0; // coupure nous sert à déterminer si le début de l'enclenchement est sous le minYDetermineOK. Si c'est le cas, on ne bouge plus rien, le reste de la boucle for (node) s'en chargera
                            for (var autreNoeuds of rad){
                                if (autreNoeuds.y + dy>minYDetermineOK && coupure == 0){
                                    autreNoeuds.y += dy;
                                    // Si son couple n'est pas dans le filtre, on le bouge quand même aussi : 
                                    var encouple = tabGene.find(function(n){return n.c_id == autreNoeuds.id;});
                                    if (typeof(encouple) != 'undefined' && jQuery.inArray( encouple.id, radID ) != -1){ // rien 
                                    }
                                    else if (typeof(encouple) != 'undefined'){
                                        encouple.y += dy;
                                    }
                                }
                                else {
                                    coupure = 1;
                                }
                            }
                        }
                    }
                var test = 'ok';
                }
                var resteADetermine = tabGene.filter(function(n){return typeof(n.ytraiteok) == 'undefined' && n.y > minYDetermineOK});
                if (resteADetermine.length > 0){ // Il reste à traiter les noeuds sans descendance
                    for (var node of resteADetermine){
                        if (typeof (node.ytraiteok) == 'undefined'){
                            // On cherche tout ses frères & soeurs                                                                                                      
                            var FetS = tabGene.filter(function (bn){return (bn.m_id != null && bn.m_id == node.m_id) || (bn.f_id != null && bn.f_id == node.f_id);});
                            // On détermine la ou l'écart en Y est le plus important
                            var ecart = 0;
                            var frere = FetS[0];
                            for (var i=0;i<FetS.length-1;i++){
                                var dd = FetS[i+1].y - FetS[i].y;
                                if (dd > ecart){ecart = dd;}
                                frere = FetS[i+1];
                            }
                            // On vérifie que la personne a au moins 1 de ces parents de renseigné (sinon, c'est une pièce rapportée dont le cas est traité par le 'encouple'
                            if (node.m_id == 'null' && node.f_id == 'null'){
                            }
                            else {
                                // On le case entre ces 2 personnes
                                var encouple = tabGene.find(function(n){return n.c_id == node.id;});
                                var delta = 0;
                                if (typeof(encouple) != 'undefined'){
                                    delta = node.y - encouple.y;
                                    node.y = frere.y + ecart/2;
                                    encouple.y = frere.y + delta + ecart/2;
                                    encouple.ytraiteok = 'ok';
                                    var nodeCouple = tabGene.find(function(n){return n.id == "c_"+node.id || n.id == "c_"+encouple.id;});
                                    if (typeof(nodeCouple) != 'undefined'){
                                        nodeCouple.y = (node.y + encouple.y)/2;
                                        nodeCouple.ytraiteok = 'ok';
                                    }
                                }
                                else {
                                    node.y = frere.y + ecart/2;
                                }
                            }
                        }
                    }
                }
            }
            
        }
        function ascendingYPosition(a, b) {
            return a.y - b.y;
        }
        function descendingYPosition(a, b) {
            return b.y - a.y;
        }
        /**
            isGeneConflit vérifie que sur une génération, tous les noeuds ont des places différentes
        */
        function isGeneConflit(tabGene,parent,nouvelDY){
            var tolerance = 0.2;
            var nouvelY = parent.y + nouvelDY;
            var tabYdejaPresent = [];
            var isinliste = 0;
            for (var node of tabGene){
                for (var i of tabYdejaPresent){
                    if (node.id == i.id){
                    // Si l'id est déjà dans cette liste, on ne l'ajoute pas
                    isinliste = 1;
                    return true;
                    }
                }
                if (isinliste == 0){
                    if (nouvelY < node.y+tolerance && nouvelY > node.y-tolerance && node.id != parent.id){
                        tabYdejaPresent.push(node);
                    }
                }
            }
            if (tabYdejaPresent.length == 0){
                return false;
            }
            else { return true;}
        }
        
        // Calcul de la taille du lien
        function calculateLinkThickness() {
          links.forEach(function (link) {
            link.thickness = link.value * yScaleFactor / 6;

          });
        }

        function relaxLeftToRight(alpha) {
          function weightedSource(link) {
            return center(link.source) * link.value;
          }

          nodesByXPosition.forEach(function (nodes) {
            nodes.forEach(function (node) {
              if (node.rightLinks.length) {
                var y = d3.sum(node.rightLinks, weightedSource) / d3.sum(node.rightLinks, value);
                node.y += (y - center(node)) * alpha;
              }
            });
          });
        }

        function relaxRightToLeft(alpha) {
          function weightedTarget(link) {
            return center(link.target) * link.value;
          }

          nodesByXPosition.slice().reverse().forEach(function (nodes) {
            nodes.forEach(function (node) {
              if (node.leftLinks.length) {
                var y = d3.sum(node.leftLinks, weightedTarget) / d3.sum(node.leftLinks, value);
                node.y += (y - center(node)) * alpha;
              }
            });
          });
        }

        function resolveCollisions() {              // Il y a qqch à faire ici pour que les y se répartissent mieux entre frères/soeurs/couples d'une même génération
          function ascendingYPosition(a, b) {
            return a.y - b.y;
          }
          nodesByXPosition.forEach(function (nodes) {
            var node,
                dy,
                y0 = 0,
                n = nodes.length,
                i;

            nodes.sort(ascendingYPosition);

            var cn = 0;
            
            for (i = 0; i < n; ++i) {
                node = nodes[i];
                node.y *= 85;
                dy = y0 - node.y;
                if (dy > 0) {
                    node.y += dy;
                }
                y0 = node.y + node.heightAllowance + 2*nodeSpacing;
            }
            
            // On rapproche les couples : 
            for (var node of nodes){
                if (cn>0 && cn<nodes.length-1 && node.type=='couple'){
                    ancienY = nodes[cn-1].y;
                    ecartAvt = node.y - ancienY;
                    ecartApr = nodes[cn+1].y - node.y;
                    nouvelYa = ancienY + (ecartAvt/3);
                    nouvelYb = node.y + (ecartApr/3);
                    nodes[cn-1].y = nouvelYa;
                    nodes[cn+1].y = nouvelYb;
                    node.y = (nodes[cn-1].y + nodes[cn+1].y) / 2;
                }
                cn++;
            }
          });
        }

        calculateYScaleFactor();
        initializeNodeYPosition();
        calculateLinkThickness();
        resolveCollisions();

        // Je ne sais pas à quoi ça sert d'itérer la dessus... 
       for (alpha = 1; iterations > 0; --iterations) {
         alpha *= 0.5;
         resolveCollisions();
       }

        minY = d3.min(nodes, function (node) { return node.y; });
        //adjustTop(minY);
      }

      function computeLinkYPositions() {
        
        function ascendingLeftNodeYPosition(a, b) {
          var aLeftNode = (a.direction > 0) ? a.source : a.target,
              bLeftNode = (b.direction > 0) ? b.source : b.target;
          return aLeftNode.y - bLeftNode.y;
        }

        function ascendingRightNodeYPosition(a, b) {
          var aRightNode = (a.direction > 0) ? a.target : a.source,
              bRightNode = (b.direction > 0) ? b.target : b.source;
          return aRightNode.y - bRightNode.y;
        }

        nodes.forEach(function (node) {
          node.rightLinks.sort(ascendingRightNodeYPosition);
          node.leftLinks.sort(ascendingLeftNodeYPosition);
        });

        nodes.forEach(function (node) {
          var rightY = 0, leftY = 0;

          node.rightLinks.forEach(function (link) {
            if (link.direction > 0) {
              link.sourceY = rightY;
              if (link.target.state === "collapsed") {
                rightY += link.thickness + linkSpacing;
              }
            }
            else {
              link.targetY = rightY;
              if (link.source.state === "collapsed") {
                rightY += link.thickness + linkSpacing;
              }
            }
          });

          node.leftLinks.forEach(function (link) {
            if (link.direction < 0) {
              link.sourceY = leftY;
              if (link.target.state === "collapsed") {
                leftY += link.thickness + linkSpacing;
              }
            }
            else {
              link.targetY = leftY;
              if (link.source.state === "collapsed") {
                leftY += link.thickness + linkSpacing;
              }
            }
          });

        });
        
        calculateLinkThickness();
      }

    function computeAbsolutePositions() {

        //setNumberOfAncestors(); Commenter car très long à s'exécuter. Besoin sur click link pour rendre invisible des noeuds
        // On redefini ce qui était calculé par le traitement de base
        for (var node of nodes){
            node.width = biHiSankey.nodeWidth();
            node.dx = biHiSankey.nodeWidth();
            //node.state = "collapsed";
            if (node.id.includes("c_")){
                var h = nodes.find(function(n){return n.id == node.id_homme;});
                var f = nodes.find(function(n){return n.id == node.id_femme;});
                node.x = (h.x + f.x) / 2;
                node.y = (h.y + f.y) / 2;
                //node.state == "collapsed";
            }
        }
        };
        
        //on essaie de déterminer combien d'ancêtre a le noeud
        function setNumberOfAncestors(){
            var remainingNodes = nodes;
            var nextNodes = [];
            nodes.forEach(function(node){
                node.nbAncetre = 0;
            });
            while (remainingNodes.length > 0){
                nextNodes = [];
                remainingNodes.forEach(function (node) {
                        // Pour chaque noeuds, on regarde si il a des ancetres
                        if (node.targetLinks.length > 0){
                            // On compte le nombre d'ancetre (nb en lien)
                            node.nbAncetre = node.nbAncetre + 1;
                            node.sourceLinks.forEach(function (link) {
                                nextNodes.push(link.target);
                            });
                        }
                    });
                remainingNodes = nextNodes;
            }
        }
        
          biHiSankey.arrowheadScaleFactor = function (_) {
            if (!arguments.length) { return arrowheadScaleFactor; }
            arrowheadScaleFactor = +_;
            return biHiSankey;
          };

          biHiSankey.collapsedNodes = function () {
            return nodes.filter(function (node) { return node.state === "collapsed"; });
          };

          biHiSankey.connected = function (nodeA, nodeB) {
            return nodeA.connectedNodes.indexOf(nodeB) >= 0;
          };

          biHiSankey.expandedNodes = function () {
            return nodes.filter(function (node) { return node.state === "expanded"; });
          };

          biHiSankey.layout = function (iterations) {
            computeAbsolutePositions();
            computeLeftAndRightLinks();
            computeNodeValues();
            computeLinkYPositions();
            return biHiSankey;
          };

          biHiSankey.link = function () {
            var curvature = defaultLinkCurvature;

            function leftToRightLink(link) {
                //if (link.source.c_id == null || link.source.c_id == "null"){   // On ne rend visible que les liens entre couples et enfants, ou entre parent seul et enfants
                  var arrowHeadLength = link.thickness * arrowheadScaleFactor,
                      straightSectionLength = (3 * link.thickness / 4) - arrowHeadLength,
                      x0 = link.source.x + link.source.width,
                      x1 = x0 + arrowHeadLength / 2,
                      x4 = link.target.x - straightSectionLength - arrowHeadLength,
                      xi = d3.interpolateNumber(x0, x4),
                      x2 = xi(curvature),
                      x3 = xi(1 - curvature),
                      y0 = link.source.y; // + link.sourceY + link.thickness / 2,
                      y1 = link.target.y; // + link.targetY + link.thickness / 2;
                  return "M" + x0 + "," + y0
                       + "L" + x1 + "," + y0
                       + "C" + x2 + "," + y0
                       + " " + x3 + "," + y1
                       + " " + x4 + "," + y1
                       + "L" + (x4 + straightSectionLength) + "," + y1;
               //}
               //else {
               //   var arrowHeadLength = link.thickness * arrowheadScaleFactor,
               //       straightSectionLength = (3 * link.thickness / 4) - arrowHeadLength,
               //       x0 = link.source.x + link.source.width,
               //       x1 = x0 + arrowHeadLength / 2,
               //       x4 = link.target.x - straightSectionLength - arrowHeadLength,
               //       xi = d3.interpolateNumber(x0, x4),
               //       x2 = xi(curvature),
               //       x3 = xi(1 - curvature),
               //       y0 = link.source.y; // + link.sourceY + link.thickness / 2,
               //       y1 = link.target.y; // + link.targetY + link.thickness / 2;
               //       // link.thickness = 0;
               //   return "M" + x0 + "," + y0
               //        + "L" + x1 + "," + y0
               //        + "C" + x2 + "," + y0
               //        + " " + x3 + "," + y1
               //        + " " + x4 + "," + y1
               //        + "L" + (x4 + straightSectionLength) + "," + y1;
               //}
            }

            function rightToLeftLink(link) {
              var arrowHeadLength = link.thickness * arrowheadScaleFactor,
                  straightSectionLength = link.thickness / 4,
                  x0 = link.source.x + link.source.width,
                  x1 = x0 - arrowHeadLength / 2,
                  x4 = link.target.x + link.target.width + straightSectionLength + arrowHeadLength,
                  xi = d3.interpolateNumber(x0, x4),
                  x2 = xi(curvature),
                  x3 = xi(1 - curvature),
                  y0 = link.source.y; // + link.sourceY + link.thickness / 2,
                  y1 = link.target.y;// + link.targetY + link.thickness / 2;
              return "M" + x0 + "," + y0
                   + "L" + x1 + "," + y0
                   + "C" + x2 + "," + y0
                   + " " + x3 + "," + y1
                   + " " + x4 + "," + y1
                   + "L" + (x4 - straightSectionLength) + "," + y1;
            }

            function link(d) {

                  if (d.source.x < d.target.x) {
                    return leftToRightLink(d);
                  }

                  return rightToLeftLink(d);
              }

            link.curvature = function (_) {
              if (!arguments.length) { return curvature; }
              curvature = +_;
              return link;
            };

            return link;
          };

          biHiSankey.links = function (_) {
            if (!arguments.length) { return links; }
            links = _.filter(function (link) {
              return link.source !== link.target; // filter out links that go nowhere
            });
            return biHiSankey;
          };

          biHiSankey.linkSpacing = function (_) {
            if (!arguments.length) { return linkSpacing; }
            linkSpacing = +_;
            return biHiSankey;
          };

          biHiSankey.nodes = function (_) {
            if (!arguments.length) { return nodes; }
            nodes = _;
            return biHiSankey;
          };

          biHiSankey.nodeWidth = function (_) {
            if (!arguments.length) { return nodeWidth; }
            nodeWidth = +_;
            return biHiSankey;
          };

          biHiSankey.nodeSpacing = function (_) {
            if (!arguments.length) { return nodeSpacing; }
            nodeSpacing = +_;
            return biHiSankey;
          };

          biHiSankey.relayout = function () {
            computeLeftAndRightLinks();
            computeNodeValues();
            computeLinkYPositions();
            return biHiSankey;
          };

          biHiSankey.size = function (_) {
            if (!arguments.length) { return size; }
            size = _;
            return biHiSankey;
          };

          biHiSankey.visibleLinks = function () {
            return visible(links);
          };

          biHiSankey.initializeNodes = function (callback) {
            initializeNodeMap();
            computeNodeHierarchy();
            computeNodeLinks();
            computeAncestorLinks();
            mergeLinks();
            computeConnectedNodes();
            nodes.forEach(callback);
            computeAbsolutePositions();
            return biHiSankey;
          };

          return biHiSankey;
        };
        
    </script>
    
    <script type="text/javascript">

    'use strict';

    var svg, tooltip, biHiSankey, path, defs, colorScale, highlightColorScale, isTransitioning;

    var OPACITY = {
        NODE_DEFAULT: 0.9,
        NODE_FADED: 0.1,
        NODE_HIGHLIGHT: 0.8,
        LINK_DEFAULT: 0.6,
        LINK_FADED: 0.05,
        LINK_HIGHLIGHT: 0.9
      },
      TYPES = ["M", "couple", "F","highlighted"],
      TYPE_COLORS = ["#77B5FE", "#d95f02", "#FD3F92","#3366FF"],
      TYPE_HIGHLIGHT_COLORS = ["#66c2a5", "#fc8d62", "#8da0cb","#4050A0"],
      LINK_COLOR = "#b3b3b3",
      INFLOW_COLOR = "#2E86D1",
      OUTFLOW_COLOR = "#D63028",
      NODE_WIDTH = 20,
      COLLAPSER = {
        RADIUS: NODE_WIDTH / 2,
        SPACING: 1
      },
      OUTER_MARGIN = 65,
      MARGIN = {
        TOP: 2.5,
        RIGHT: 2.5,
        BOTTOM: 2.5,
        LEFT: 2.5

      },
      TRANSITION_DURATION = 400,
      HEIGHT = 900 - MARGIN.TOP - MARGIN.BOTTOM,
      WIDTH =  600 - MARGIN.LEFT - MARGIN.RIGHT,
      LAYOUT_INTERATIONS = 0,
      REFRESH_INTERVAL = 3500;
      
    var map;
    var apikey = "261bbc94c8266573016ba9454127b905b931b0a6";
    var user = 'samuel';
    var sublayers = [];

    function trouverNodes(flagRecherche,elementsRecherches){
        var noeuds = [];
        var sql_statement = "SELECT * FROM nodes WHERE arbre = '1' OR arbre = '2'";
        if (flagRecherche == 1){
            // Dans ce cas, on ajoute une clause WHERE à la recherche
            sql_statement += " AND WHERE ";
            for (var el of elementsRecherches){
                sql_statement += "own_id = '" + el.id + "' OR ";
            }
            sql_statement = sql_statement.substring(0,sql_statement.length - 4);
            //alert("flag-- " + sql_statement);
        }
        $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
            if (data_json.rows.length == 0){
                // Il n'y a personne dans la table
                alert("Il n'y a pas encore de personne dans cet arbre !");
            }
            else if (data_json.rows.length > 0){
                    // Pour chaque ligne, on vérifie
                    for (var r of data_json.rows){
                        noeuds.push({"id":r.own_id,"parent":null,"nom":r.nom,"prenom":r.prenom,"mere":r.mother_id,"pere":r.father_id,"genre":r.genre,"arbre":r.arbre});
                    }
            }
        });
        return noeuds;
    }
    
    // Get the nodes from cartodb table
    // flagRecherche = 0 : pas de choix de personne à rechercher, 1 : on recherche l'arbre d'une personne en particulier
    function populateNode(flagRecherche,elementsRecherches){
        var sql_statement = "SELECT * FROM nodes WHERE arbre = '1' OR arbre = '2'";
        if (flagRecherche == 1 && elementsRecherches.length > 0){
            // Dans ce cas, on ajoute une clause WHERE à la recherche
            sql_statement += " AND WHERE ";
            for (var el of elementsRecherches){
                sql_statement += "own_id = '" + el.id + "' OR ";
            }
            sql_statement = sql_statement.substring(0,sql_statement.length - 4);
            //alert("flag-- " + sql_statement);
        }
        var NoeudsBase = [];
        if (flagRecherche == 1 && elementsRecherches.length > 0){
            //biHiSankey.nodes = [];
            //biHiSankey.links = [];
            NoeudsBase = trouverNodes(flagRecherche,elementsRecherches);}
        else {
            NoeudsBase = trouverNodes(0,[]);
        }
        $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
            if (data_json.rows.length == 0){
                // Il n'y a personne dans la table
                document.getElementById('titre').innerHTML = "Il n'y a pas encore de personne dans cet arbre !";
                hideObject(table_carnet);
            }
            else if (data_json.rows.length > 0){
                    // Pour chaque ligne, on l'ajoute au tableau des noeuds. 
                    // Et on formatte le tableau pour qu'il soit exploitable par D3
                    var nodes, links, liste_couple;
                    nodes = [];
                    links = [];
                    liste_couple = [];
                    for (var r of data_json.rows){
                        // On remplit les personnes
                        nodes.push({"type":r.genre,"id":r.own_id,"parent":null,"name":r.nom,"prenom":r.prenom,"f_id":r.father_id,"m_id":r.mother_id,"c_id":r.couple_id,"dBirth":r.date_naissance,"dDie":r.date_deces,"dMar":r.date_mariage,"job":r.profession,"comm":r.commentaire,"arbre":r.arbre,"adr_photo":r.adr_photo,"x":r.x,"y":r.y});
                        // Si 1 des 2 parents est en couple, on ajoute un noeud
                        if ((r.couple_id != null && r.couple_id != "null")){
                            var isinliste = 0;
                            for (var lc of liste_couple){
                                if (lc.id_c == r.own_id){
                                    // Si l'id est déjà dans cette liste, on ne l'ajoute pas
                                    isinliste = 1;
                                }
                            }
                            if (isinliste == 0){
                                //var Pere = NoeudsBase.find(function(a){return a.id == r.father_id});
                                var homme = NoeudsBase.find(function(a){return a.id == r.own_id && r.genre == "M"});
                                var saFemme;
                                if (homme){
                                    nodes.push({"type":"couple","id":"c_"+r.couple_id,"parent":null,"name":homme.nom,"prenom":homme.prenom,"id_homme":r.own_id,"id_femme":r.couple_id,"dMar":r.date_mariage,"arbre":r.arbre});
                                    liste_couple.push({"id_c":r.couple_id,"id_homme":r.own_id});
                                    links.push({"source":homme.id,"target":"c_"+r.couple_id,"value":1});
                                    links.push({"source":r.couple_id,"target":"c_"+r.couple_id,"value":1});
                                }
                            }
                        }
                        // On calcul les liens 
                        var pereExiste = NoeudsBase.find(function(a){return a.id == r.father_id});
                        var mereExiste = NoeudsBase.find(function(a){return a.id == r.mother_id});

                        if (r.father_id == null || r.father_id == " " || r.father_id == "null" || typeof(pereExiste) == 'undefined'){}
                        else {
                            links.push({"source":r.father_id,"target":r.own_id,"value":1});
                            }
                        if (r.mother_id == null || r.mother_id == " " || r.mother_id == "null"  || typeof(mereExiste) == 'undefined'){}
                        else {
                            links.push({"source":r.mother_id,"target":r.own_id,"value":1});
                        }
                    }
                    // Une fois les nodes remplis, on ajoute "parent" des noeuds des personnes en couple : 
                    for (var p of nodes){
                        for (var lc of liste_couple){
                            if (p.id == lc.id_c || p.id == lc.id_homme){
                                p.parent = "c_"+lc.id_c;
                            }
                        }
                    }
                    
            }
            
            //return nodes;
            //return({nodes,links});
            if (flagRecherche == 1 && elementsRecherches.length == 0){
            }
            else {
                drawTree(nodes,links);
            }
            
            if (flagRecherche != 0){
                return [nodes,links];
            }
            });
    }

    var formatNumber = function (d) {
      var numberFormat = d3.format(",.0f"); // zero decimal places
      return " - " + numberFormat(d);
    },

    formatFlow = function (d) {
      var flowFormat = d3.format(",.0f"); // zero decimal places with sign
      return flowFormat(Math.abs(d));
    },

    // Used when temporarily disabling user interractions to allow animations to complete
    disableUserInterractions = function (time) {
      isTransitioning = true;
      setTimeout(function(){
        isTransitioning = false;
      }, time);
    },

    hideTooltip = function () {
    tooltip.transition().style("opacity",0).select(".cimg").attr("src","");
      return tooltip.transition()
        .duration(TRANSITION_DURATION)
        .style("opacity", 0);
    },

    showTooltip = function () {
      return tooltip
        // .style("left", d3.event.layerX + "px")
        // .style("left", "0 px")
        // .style("top", d3.event.layerY + 15 + "px")
        // .style("float", "15 px")
        .transition()
          .duration(TRANSITION_DURATION)
          .style("opacity", 1);
    };
    
    
    colorScale = d3.scale.ordinal().domain(TYPES).range(TYPE_COLORS),
    highlightColorScale = d3.scale.ordinal().domain(TYPES).range(TYPE_HIGHLIGHT_COLORS),
    
    svg = d3.select("#chart").append("svg")
            .attr("id","id_svg")
            .attr("width", "100%")
            .attr("height", "900px")
            //.attr("viewBox","0 -100 1450 1600") //cadre sur l'ensemble des noeuds 
            .attr("viewBox","0 -100 2500 3400") //cadre sur l'ensemble des noeuds 
            .attr("style",function(){
                return "transform:rotate(90deg);";}) // tourne la map de haut en bas // overflow: visible
            // .call(zoom)
            .call(d3.behavior.zoom().on("zoom", function () {       // Permet de gérer le zoom et le déplacement
                console.log("on zoom !");
                var x = d3.event.translate[1];
                var y = -d3.event.translate[0];
                console.log("transform", "translate(" + x + ","+ y +")" + " scale(" + d3.event.scale + ")")
                svg.attr("transform", "translate(" + x + ","+ y +")" + " scale(" + d3.event.scale + ")")
              }))
          .append("g");
            //.attr("transform", "translate(" + -100 + "," + 100 + ") scale(0.17)");
    svg.append("g").attr("id", "path_time");
    svg.append("g").attr("id", "links");
    svg.append("g").attr("id", "nodes");
    svg.append("g").attr("id", "collapsers");

    
    tooltip = d3.select("#sideTooltip").append("div").attr("id", "tooltip");
    tooltip.style("width", "390px");
    tooltip.style("margin-left", "0px");
    tooltip.style("margin", "20px");
    tooltip.style("opacity", 0)
        .append("img")
          .attr("src", "")
          .attr("alt","")
          // .attr("height","60px")
          // .attr("width","45px")
          .attr("class","cimg")
          .attr("style","float:right")
          ;
    tooltip.style("opacity", 0)
        .append("div")
          .attr("class", "titre_nom")
          .attr("id","id_ptool")
          .attr("style","float:left")
          ;
    tooltip.style("opacity", 0)
        .append("div")
          .attr("class", "value")
          .attr("id","id_ptool")
          .attr("style","float:left")
          ;
          
    biHiSankey = d3.biHiSankey();

    // Set the biHiSankey diagram properties
    biHiSankey
      .nodeWidth(NODE_WIDTH)
      .nodeSpacing(24)
      .linkSpacing(1)
      .arrowheadScaleFactor(0.5) // Specifies that 0.5 of the link's stroke WIDTH should be allowed for the marker at the end of the link.
      .size([WIDTH, HEIGHT]);

          
      // Définition de la flêche 
    path = biHiSankey.link().curvature(0.5);
    
    defs = svg.append("defs");

    defs.append("marker")
      .style("fill", LINK_COLOR)
      .attr("id", "arrowHead")
      .attr("viewBox", "0 0 6 10")
      .attr("refX", "1")
      .attr("refY", "5")
      .attr("markerUnits", "strokeWidth")
      .attr("strokeWidth", "20px")
      .attr("markerWidth", "1")
      .attr("markerHeight", "5")
      .attr("orient", "auto")
      .append("path")
        .attr("d", "M 0 0 L 1 0 L 6 5 L 1 10 L 0 10 z");

    defs.append("marker")
      .style("fill", OUTFLOW_COLOR)
      .attr("id", "arrowHeadInflow")
      .attr("viewBox", "0 0 6 10")
      .attr("refX", "1")
      .attr("refY", "5")
      .attr("markerUnits", "strokeWidth")
      .attr("strokeWidth", "20px")
      .attr("markerWidth", "1")
      .attr("markerHeight", "1")
      .attr("orient", "auto")
      .append("path")
        .attr("d", "M 0 0 L 1 0 L 6 5 L 1 10 L 0 10 z");

    defs.append("marker")
      .style("fill", INFLOW_COLOR)
      .attr("id", "arrowHeadOutlow")
      .attr("viewBox", "0 0 6 10")
      .attr("refX", "1")
      .attr("refY", "5")
      .attr("markerUnits", "strokeWidth")
      .attr("strokeWidth", "20px")
      .attr("markerWidth", "1")
      .attr("markerHeight", "1")
      .attr("orient", "auto")
      .append("path")
        .attr("d", "M 0 0 L 1 0 L 6 5 L 1 10 L 0 10 z");
        
    function update () {
      var link, linkEnter, node, nodeEnter, collapser, collapserEnter;

     function dragmove(node) {
       node.x = Math.max(0, Math.min(WIDTH - node.width, d3.event.x));           // On supprime cette ligne pour ne garder que le déplacement vertical. 
       //node.y = Math.max(0, Math.min(HEIGHT - node.height, d3.event.y));
       //d3.select(this).attr("transform", "translate(" + node.x + "," + node.y + ")");
       //biHiSankey.relayout();
       svg.selectAll(".node").selectAll("circle").attr("height", function (d) { return d.height; });
       link.attr("d", path);
     }

      function containChildren(node) {

        node.children.forEach(function (child) {
          child.state = "contained";
          child.parent = this;
          child._parent = null;
          containChildren(child);
        }, node);
      }

      function expand(node) {
        node.state = "expanded";
        node.children.forEach(function (child) {
          child.state = "collapsed";
          child._parent = this;
          child.parent = null;
          containChildren(child);
        }, node);
      }

      function collapse(node) {
        node.state = "collapsed";
        containChildren(node);
      }

      function restoreLinksAndNodes() {
        link
          .style("stroke", LINK_COLOR)
          .style("marker-end", function () { return 'url(#arrowHead)'; })
          .transition()
            .duration(TRANSITION_DURATION)
            .style("opacity", function(d){
                return d.id.includes("c_") || isParentCelib(d) ? 1:0
                });

        //node
          //.selectAll("circle")
            //.style("fill", function (d) {
            //  d.color = colorScale(d.type.replace(/ .*/, ""));
            //  return d.color;
            //})
            //.style("fill","url(#mImg)")
            //.style("stroke", function (d) {
            //  return d3.rgb(colorScale(d.type.replace(/ .*/, ""))).darker(0.1);
            //})
            //.style("fill-opacity", OPACITY.NODE_DEFAULT);

        node.filter(function (n) { return !n.id.includes("c_"); })
          .transition()
            .duration(TRANSITION_DURATION)
            .style("opacity", 1);
      }

      function showHideChildren(node) {
        disableUserInterractions(2 * TRANSITION_DURATION);
        hideTooltip();
        if (node.state === "collapsed") { expand(node); }
        else { collapse(node); }

        biHiSankey.relayout();
        update();
        link.attr("d", path);
        restoreLinksAndNodes();
      }
      
        function hide(node) {
        disableUserInterractions(2 * TRANSITION_DURATION);
        hideTooltip();
        if (typeof(node.state) != 'undefined'){
            if (node.state === "collapsed") {expand(node); }
            else if (node.state === "contained") { 
                expand(node); 
                var him = noeudsExistants.find(function(a){a.id == node.id});
                var her = noeudsExistants.find(function(a){a.c_id == node.id});
                //collapse(him);
                //expand(her);
            }
            else { /*collapse(node);*/ }
        }
        biHiSankey.relayout();
        update();
        link.attr("d", path);
        restoreLinksAndNodes();
      }
      
      function highlightConnected(g) {
        link.filter(function (d) {
            if (d.source ===g){
                console.log("source : " + d.source.id); 
                return true;}
            if ((d.source != null || d.target != null)){           // On récupère les enfants et le conjoint
                if (!isParentCelib(d) && g.parent !=null){
                    if (d.target.id == g.parent.id || d.source.id == g.parent.id){
                        console.log("source : " + d.source.id + " - " + d.target.id);
                        return true;
                    }
                    else if (g.parent == null){
                        return (d.target === g || d.target.id == g.id)
                    }
                }
                else {
                    return false;
                }
            }
            return false;
        })        
          .style("marker-end", function () { return 'url(#arrowHeadInflow)'; })
          .style("stroke", OUTFLOW_COLOR) // rouge
          .style("opacity", 1);

        link.filter(function (d) { 
            if (d.target != null){
                if (!isParentCelib(d) && g.parent !=null){
                    if (d.target === g || d.target.id == g.parent.id) {console.log ("target : " + d.target === g + " - " + d.target.id + " - " + d.target.id);}
                    return (d.target === g || d.target.id == "c_"+g.f_id || d.target.id == "c_"+g.m_id || d.target.id == g.parent.id) ;
                }
                else if (g.parent == null){
                    return (d.target === g || d.target.id == g.id || d.target.id == "c_"+g.f_id || d.target.id == "c_"+g.m_id)
                }
            }
        })     // On récupère les parents
          .style("marker-end", function () { return 'url(#arrowHeadOutlow)'; })
          .style("stroke", INFLOW_COLOR)
          .style("opacity", 1);
      }

      function fadeUnconnected(g) { // Il manque le cas des personnes célibataires
        link.filter(function (d) {
            if (d.source != null && d.target != null && g.parent != null){
                return d.source !== g && d.source.id != g.parent.id && d.target !== g && d.target.id != g.parent.id && d.target.id != "c_"+g.f_id && d.target.id != "c_"+g.m_id; 
            }
        })  
          .style("marker-end", function () { return 'url(#arrowHead)'; })
          .transition()
            .duration(TRANSITION_DURATION)
            .style("opacity", OPACITY.LINK_FADED);

        node.filter(function (d) {return !biHiSankey.connected(d, g) && !d.id.includes("c_") && d !== g;    // On fade les non-reliés
        }).transition()
          .duration(TRANSITION_DURATION)
          .style("opacity", OPACITY.NODE_FADED);
      }
      
    function isParentCelib(link){
        var nodes = biHiSankey.nodes();
        var isInCouple = 0;
        var isParent = 0;
        if (link.source != null){
            nodes.forEach(function (n) {
                if (n.c_id == link.source.id){
                    isInCouple += 1; // Si la personne est en couple avec le noeud, c'est mort
                }    
            });
            nodes.forEach(function(n){
                if (n.f_id == link.source.id || n.m_id == link.source.id){
                    isParent += 1;    
                }
            });
        }
        if (isInCouple == 0&& isParent>0){return true;}
        else {return false;}
    }
    
    /**
    Gestion des images affichées sur les noeuds
    */
    function addImage(noeud){
    if (noeud.length > 1){
        noeud = noeud.find(function(g){return g.id == noeud.id});
    }
    
        var pat = noeud.append("pattern")
        .attr("id","mImg")
        .attr("x","0")
        .attr("y","0")
        .attr("width", "48px")
        .attr("height", "48px")
        .style("fill","transparent")
        .style("stroke","back")
        .style("stroke-width","0.25");

        pat.append("image")
        .attr("xlink:href", function(d) { 
                var image = 'https://raw.githubusercontent.com/samueldb/samueldb.github.io/master/images/portraits/'+d.id+'.jpg';
                if (d.type == 'couple'){
                    image = 'https://raw.githubusercontent.com/samueldb/samueldb.github.io/master/images/image_couple.png';
                }
                else if (d.adr_photo != null){
                    image = d.adr_photo;
                    }
                else if (d.adr_photo == null){
                    image = 'https://raw.githubusercontent.com/samueldb/samueldb.github.io/master/images/no_photo.png';
                    }
                return image;
            })
        .attr("x", "-0")
        .attr("y", "-0")
        .attr("width", "48px")
        .attr("height", "48px");
    
    }
      link = svg.select("#links").selectAll("path.link")
        .data(biHiSankey.visibleLinks(), function (d) { return d.id; });


      link.transition()
        .duration(TRANSITION_DURATION)
        .style("stroke-WIDTH", function (d) { return Math.max(1, d.thickness); })
        .attr("d", path)
        .style("opacity", function(d){return d.id.includes("c_") || isParentCelib(d) ? 1:0});
      link.exit().remove();
      linkEnter = link.enter().append("path")
        .attr("class", "link")
        .style("fill", "none");
        
      linkEnter.on('mouseenter', function (d) {
        if (!isTransitioning) {
          showTooltip().select(".value").text(function () {
            if (d.direction > 0) {
              // return d.source.id + "--" + d.source.prenom + " -> " + d.target.prenom + " " + d.target.name + "\n";
              return "direction " + d.direction + "-" + d.source.id + "--> " + d.target.id + "\n";
            }
            // return d.target.id + "--" + d.target.name + " <- " + d.source.name + d.source.prenom + "\n";
            return "direction " + d.direction + "-" + d.source.id + "--> " + d.target.id + "\n";
            });

          d3.select(this)
            .style("stroke", LINK_COLOR)
            .transition()
              .duration(TRANSITION_DURATION / 2)
              .style("opacity", function(d){return d.id.includes("c_") || isParentCelib(d) ? 1:0});
        }
      });

      linkEnter.on('mouseleave', function () {
        if (!isTransitioning) {
          hideTooltip();

          d3.select(this)
            .style("stroke", LINK_COLOR)
            .transition()
              .duration(TRANSITION_DURATION / 2)
              .style("opacity", function(d){return d.id.includes("c_") || isParentCelib(d) ? 1:0});
        }
      });

      linkEnter.sort(function (a, b) { return b.thickness - a.thickness; })
        .classed("leftToRight", function (d) {
          return d.direction > 0;
        })
        .classed("rightToLeft", function (d) {
          return d.direction < 0;
        })
        .style("marker-end", function () {
          return 'url(#arrowHead)';
        })
        .style("stroke", LINK_COLOR)
        .style("opacity", 0)
        .transition()
          .delay(TRANSITION_DURATION)
          .duration(TRANSITION_DURATION)
          .attr("d", path)
          .style("stroke-WIDTH", function (d) { return Math.max(1, d.thickness); })
          .style("opacity", function(d){return d.id.includes("c_") || isParentCelib(d) ? 1:0});


      node = svg.select("#nodes").selectAll(".node")
          .data(biHiSankey.collapsedNodes(), function (d) { return d.id; });
          
      //var sous_nodes = svg.select("#sous_nodes").selectAll(".node").data(biHiSankey.nodes().filter(function(a){return a.id == noeudFocus.id;}))

      
      node.transition()
        .duration(TRANSITION_DURATION)
        .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; })
        .style("opacity", function(d){return d.id.includes("c_") ? 1:0})
        //.select("circle")
          //.style("fill", function (d) {
          //  d.color = colorScale(d.type.replace(/ .*/, ""));
          //  return d.color;
          //})
          //.style("fill","url(#mImg)")
          //.style("stroke", function (d) { return d3.rgb(colorScale(d.type.replace(/ .*/, ""))).darker(0.1); })
          //.style("stroke-WIDTH", "1px")
          //.attr("height", function (d) { return d.height; })
          //.attr("width", biHiSankey.nodeWidth());


      node.exit()
        .transition()
          .duration(TRANSITION_DURATION)
          .attr("transform", function (d) {
            var collapsedAncestor, endX, endY;
            collapsedAncestor = d.ancestors.filter(function (a) {
              return a.state === "collapsed";
            })[0];
            endX = collapsedAncestor ? collapsedAncestor.x : d.x;
            endY = collapsedAncestor ? collapsedAncestor.y : d.y;
            return "translate(" + endX + "," + endY + ")";
          })
          .remove();


      nodeEnter = node.enter().append("g").attr("class", "node");

      // Ne sont concerné ici que les noeuds uniques visible au départ
      nodeEnter
        .attr("transform", function (d) {
        var sX = 0;
        var sY = 0;
        if (d._parent){
            sX = d._parent.x;
        }
        else if (d.children.length > 1){
            sX = Math.max(d.children[0].x,d.children[1].x);
            sY = Math.max(d.children[0].y,d.children[1].y);
        }
        else {
            sX = d.x;
            sY = d.y;
        }
          return "translate(" + sX + "," + sY + ")";
        })
        .style("opacity", function(d){return d.id.includes("c_") ? 0:1})
        .transition()
          .duration(TRANSITION_DURATION)
          .style("opacity", function(d){return d.id.includes("c_") ? 0:1})
          .attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; });

        addImage(nodeEnter);
        
        var circle = nodeEnter.append("circle")
            .attr("cx", 0)
             .attr("cy", 0)
             .attr("r", 24)     
             .style("stroke", "black")     
             .style("stroke-width", 0.5)
             .style("transform","rotate(-90deg)")
            .style("fill","url(#mImg)");
      
    nodeEnter.append("text");
      
    node.on("click",function(g){
            console.log("click sur "+g.prenom);
                //alert('on a tiré sur : '+g.prenom);
        })
     node.on("mouseover", function (g) { 
       console.log("mouseoever sur "+g.id+" : "+g.prenom);
       if (!isTransitioning && !g.id.includes("c_")) {
         // restoreLinksAndNodes();
         highlightConnected(g);
         fadeUnconnected(g);
         addImage(node);
       
         tooltip
           .transition()
             .duration(TRANSITION_DURATION)
             .style("opacity", 1).select(".titre_nom")
             .text(function () {
               var info = g.name + "\n " + g.prenom;
               return info;
             });
         // On ajoute l'image récupérée sur github :     
          tooltip.transition().style("opacity",1).select(".cimg").attr("src",'https://raw.githubusercontent.com/samueldb/samueldb.github.io/master/images/portraits/'+g.id+'.jpg');
    
    
         tooltip
           .transition()
             .duration(TRANSITION_DURATION)
             .style("opacity", 1).select(".value")
             .text(function () {
               var nomsCouples = '';
               var additionalInstructions = g.children.length ? "\n " +g.dMar ? "\n Date de mariage : "+ formatDate(g.dMar): "" +"(Double clic pour ouvrir)" : ("\n Date de naissance : " + (g.dBirth ? formatDate(g.dBirth) : "non renseignée") + (g.dDie ? ("\n Date de décès : " + formatDate(g.dDie)) : "") + "\n Profession : " + (g.job ? g.job:"non renseignée") + "\n " + (g.comm ? g.comm:" - ") );
               if (g.children.length){
                   var nomC1 = g.children[0].name + ' ' + g.children[0].prenom;
                   var nomC2 = g.children[1].name + ' ' + g.children[1].prenom;
                   nomsCouples = nomC1 + '\n' + nomC2;
               }
               else {
                   nomsCouples = g.name + ' ' + g.prenom;
               }
               return additionalInstructions;
             });
         // On ajoute l'image récupérée sur github :     
           // tooltip.transition().style("opacity",1).select(".cimg").attr("src",'https://raw.githubusercontent.com/samueldb/samueldb.github.io/master/images/portraits/'+g.id+'.jpg');
       }
     });
     
     /**
        Gestion de la barre des temps
     */
      var minYear = 2000;
      for (var n of biHiSankey.nodes()){
        if (typeof(n.dBirth) != 'undefined' && n.dBirth != 'null' && n.dBirth != null){
            if (minYear > parseInt(n.dBirth.substring(0,4))){
                minYear = parseInt(n.dBirth.substring(0,4));
            }
        }
      }
        var x = d3.scale.linear()
            .domain([minYear, 2015])
            .range([minYear, WIDTH]);
        //var x =d3.time.scale().range([0, WIDTH]);
        var xAxis = d3.svg.axis().scale(x)
            .orient("bottom").ticks(5);
        
        var valueline = d3.svg.line()
            .x(function(d) { 
                if (typeof(d.dBirth) != 'undefined' && d.dBirth != 'null' && d.dBirth != null){
                    return x(parseInt(d.dBirth.substring(0,4))); 
                }
                else return 1800;
            })
            .y(function(d) { return 0; });
        
        //svg.append("g")
        //    .attr("class", "x axis")  // two classes, one for css formatting, one for selection below
        //    .attr("transform", "translate(0," + (HEIGHT-25) + ")")  // HEIGHT-10
        //    .attr("d", valueline(biHiSankey.nodes()))
        //    .call(xAxis);
        //svg.append("text")                                                              // ajout du titre du graph
        //.attr("transform", "translate(" + (WIDTH / 2) + " ," + (HEIGHT + 25) + ")")
        //.style("text-anchor", "middle")
        //.text("Date");
        
      function formatDate(date){
        var dateFormatee = "";
        if (date != 'undefined' && date != "null" && date !=null){
            dateFormatee = date.substring(8,10) + " " + getMonth(date.substring(5,7)) + " " + date.substring(0,4);
        }
        else {dateFormatee = "non renseignée";}
        return dateFormatee;
      }
      
      function getMonth(mm){
      switch(mm)
        {
            case "01":return "Janvier";
            case "02":return "Fevrier";
            case "03":return "Mars";
            case "04":return "Avril";
            case "05":return "Mai";
            case "06":return "Juin";
            case "07":return "Juillet";
            case "08":return "Aout";
            case "09":return "Septembre";
            case "10":return "Octobre";
            case "11":return "Novembre";
            case "12":return "Decembre";
        }
      }

     node.on("mouseleave", function () {
       if (!isTransitioning) {
         hideTooltip();
         restoreLinksAndNodes();
         addImage(node);
       }
     });

      //node.filter(function (d) { return d.children.length; })
      //  .on("dblclick", showHideChildren);



//    var textes = svg.select("#nodes").selectAll(".node.text")});
//        textes.on("dblclick",alert('greet tests'));
        
        
      // allow nodes to be dragged to new positions
      node.call(d3.behavior.drag()
        .origin(function (d) { return d; })
        .on("dragstart", function () { this.parentNode.appendChild(this); })
        .on("drag", dragmove));

      // Ajouter du texte sur les noeuds
      node.filter(function (d) { 
                    return  d.value > -1  ; 
                    //return true;
                    }) // ici, on peut filter les noms des noeuds auxquels seront ajouté les textes
        .select("text")
          .attr("x", function (d) { return d.width; })
          .attr("y", function (d) { return d.height; })
          .attr("dy", ".35em")
          .attr("text-anchor", "bottom")
          .attr("transform", "rotate(225) translate(5,-15)") //function (d) { return d.height; }+");")
          .text(function (d) {
                var txt = "";
                if (d.name.includes(" ") ||d.name.includes("-")){
                    var index = d.name.indexOf(" ");
                    if (index == -1){
                        index = d.name.indexOf("-");
                    }
                    txt = d.prenom + " " + d.name[0]+ "." + d.name[index+1]+ "." ;
                }

                else {
                    txt = d.prenom + " " + d.name[0]+ "." ;
                }
                return txt;
            })
        .filter(function (d) { return d.x < WIDTH / 2; })
          .attr("x", 6 + biHiSankey.nodeWidth())
          .attr("text-anchor", "start");


          
        //node.attr("rotateZ","90deg");
        node.attr("id",function(d){return d.id;});
      collapser = svg.select("#collapsers").selectAll(".collapser")
        .data(biHiSankey.expandedNodes(), function (d) { return d.id; });


      collapserEnter = collapser.enter().append("g").attr("class", "collapser");

      collapserEnter.append("circle")
        .attr("r", COLLAPSER.RADIUS)
       // .style("fill", function (d) {
       //   d.color = colorScale(d.type.replace(/ .*/, ""));
       //   return d.color;
       // });

      collapserEnter
        .style("opacity", function(d){return d.id.includes("c_") ? 0:1})
        .attr("transform", function (d) {
          return "translate(" + (d.x + d.width / 2) + "," + (d.y + COLLAPSER.RADIUS) + ")";

        });

      //collapserEnter.on("dblclick", showHideChildren);

      collapser.select("circle")
        .attr("r", COLLAPSER.RADIUS);

      collapser.transition()
        .delay(TRANSITION_DURATION)
        .duration(TRANSITION_DURATION)
        .attr("transform", function (d, i) {
          return "translate("
            + (COLLAPSER.RADIUS + i * 2 * (COLLAPSER.RADIUS + COLLAPSER.SPACING))
            + ","
            + (-COLLAPSER.RADIUS - OUTER_MARGIN)
            + ")";
        });

      collapser.on("mouseenter", function (g) {
        if (!isTransitioning) {
          showTooltip().select(".value")
            .text(function () {
                var nomsCouples = '';
                if (g.children.length){
                    var nomC1 = g.children[0].name + ' ' + g.children[0].prenom;
                    var nomC2 = g.children[1].name + ' ' + g.children[1].prenom;
                    nomsCouples = nomC1 + '\n' + nomC2;
                }
                else {
                    nomsCouples = g.name + ' ' + g.prenom;
                }
              return nomsCouples + "\n(Double clic pour refermer)";
            });

          var highlightColor = highlightColorScale(g.type.replace(/ .*/, ""));

         // d3.select(this)
         //   .style("opacity", OPACITY.NODE_HIGHLIGHT)
         //   .select("rect")
         //     .style("fill", highlightColor);

       //   node.filter(function (d) {
       //   return (d.target === g) ? false : !biHiSankey.connected(d, g);
       // }).style("opacity", OPACITY.NODE_HIGHLIGHT)
       //     .select("rect")
       //       .style("fill", highlightColor);
              
          node.filter(function (d) {
              return (d.arbre != '1' || d.arbre != '2')
            }).style("opacity", function(d){return d.id.includes("c_") ? 0:1});
//                .select("rect")
//                  .style("fill", "url(#mImg)");
        }
      });

      collapser.on("mouseleave", function (g) {
        if (!isTransitioning) {
          hideTooltip();
          addImage(collapser);
        //  d3.select(this)
        //    .style("opacity", function(d){return d.id.includes("c_") ? 0:1})
        //    .select("rect")
        //      .style("fill","url(#mImg)");
        //
        //  node.filter(function (d) {
        //      return (d.source === g) ? false : !biHiSankey.connected(d, g);
        //    }).style("opacity", function(d){return d.id.includes("c_") ? 0:1})
        //        .select("rect")
        //          .style("fill", "url(#mImg)");
        }
      });

      collapser.exit().remove();

        link.on("click", function(g){
          if (!isTransitioning){
            //alert('on vient de cliquer !');
            var gSource = g.source;
            // On récupère tous les enfants : 
            var Noeuds =biHiSankey.nodes();
            var nodeD = Noeuds.find(function(a){return a.id == gSource.id || 'c_'+a.id == gSource.id});
            var e1 = getEnfants(nodeD,Noeuds);
            for (var e of e1){
                if (e.c_id != "null" && e.c_id != "" && e.c_id != null){
                    // Si l'enfant a un conjoint, on cache le couple
                    var noeudCouple = Noeuds.find(function(a){return a.id == 'c_'+e.id || a.id == 'c_'+e.c_id;});
                    hide(noeudCouple);
                    var conj = Noeuds.find(function(a){return a.c_id == e.id;});
                    // Si le conjoint n'a pas d'ancetre, on le cache aussi :
                    if (conj.nbAncetre == 0){
                        hide(conj);
                        // On cherche les enfants de l'enfant :
                        var e2 = getEnfants(e,Noeuds);
                        for (var e2e of e2){
                            e1.push(e2e);
                        }
                    }
                    else {
                        
                    }
                }
                else {
                    // On cherche les enfants de l'enfant sans conjoint :
                    var e2 = getEnfants(e,Noeuds);
                    for (var e2e of e2){
                        e1.push(e2e);
                    }
                }
                hide(e);
                
            }
            }
          });
    }
    
    populateNode();
    function drawTree(nodesTree,linksTree){
        biHiSankey
          .nodes(nodesTree)
          .links(linksTree)
          .initializeNodes(function (node) {
            //node.state = node.parent ? "contained" : "collapsed";
            node.state = "collapsed";
            //node.id = node.id;
          })
          .layout(LAYOUT_INTERATIONS);

        disableUserInterractions(2 * TRANSITION_DURATION);

        update();
    }
    
    function remplirFamille(nomFamille){
        //showObject(liste_old_prenom);
        viderListe(liste_old_prenom);
        var select = document.getElementById("liste_old_prenom"); 
        var genre_sel = $(genres_search).val(); 
        var el = document.createElement("option");
        el.textContent = " ";
        el.value = " ";
        select.appendChild(el);
        for (var p of noeudsExistants.filter(function (a){return a.nom == nomFamille && a.genre == genre_sel})){
            var select = document.getElementById("liste_old_prenom"); 
            var el = document.createElement("option");
            el.textContent = p.prenom;
            el.value = p.id;
            select.appendChild(el);
        }
    }
    
    function hideObject(obj){
        $(obj).css('visibility','hidden');
        $(obj).css('display','none');
    }

    function showObject(obj){
        $(obj).css('visibility','visible');
        $(obj).css('display','initial');
    }
    
    function viderListe(liste){
        liste.options.length=0;
    }
    
    function formatDate(date){
        var dateFormatee = "";
        if (date == null ||date == "null" || date == "") return "null";
        else {dateFormatee = date.substring(8,10) + " " + getMonth(date.substring(5,7)) + " " + date.substring(0,4);
        return dateFormatee;
        }
    }

    function getMonth(mm){
        switch(mm)
        {
            case "01":return "Janvier";
            case "02":return "Fevrier";
            case "03":return "Mars";
            case "04":return "Avril";
            case "05":return "Mai";
            case "06":return "Juin";
            case "07":return "Juillet";
            case "08":return "Aout";
            case "09":return "Septembre";
            case "10":return "Octobre";
            case "11":return "Novembre";
            case "12":return "Decembre";
        }
    }
    /**
        Focus du graph sur une personne en particulier
    */
    function focusPersonne(value){
        console.log("on focus sur " + value);
        hideObject(focus_p);
        showObject(reinit);
        var personne = value;
        
        // On met en surbrillance la personne concernée
        var selNodes = svg.select("#nodes").selectAll(".node").data(biHiSankey.nodes());
        selNodes.filter(function(d){return d.id != personne;}).style("opacity",function(d){return d.id.includes("c_") ? 0:0.1});
        selNodes.filter(function(d){return d.id == personne;}).attr("selected","true");
        var link = svg.select("#links").selectAll("path.link").data(biHiSankey.visibleLinks(), function (d) { return d.id; });
        link.style("opacity",0);
        var node = biHiSankey.nodes().find(function(d){return d.id == personne;});
        var centreX = biHiSankey.size()[0]/2;
        var centreY = biHiSankey.size()[1]/2;
        var dx = centreX - node.x;
        var dy = centreY - node.y;
        svg.attr("transform", "translate(" + dx + "," + dy + ")");
        selNodes.filter(function(d){return d.id == personne;}).mouseover();
    }
    
    function reinitialiser(){
        var selNodes = svg.select("#nodes").selectAll(".node").data(biHiSankey.nodes().filter(function(a){return a.id;}));
        selNodes.filter(function(d){return d.selected != "true" && !d.id.includes("c_");}).style("opacity",1);
        var link = svg.select("#links").selectAll("path.link").data(biHiSankey.visibleLinks(), function (d) { return d.id; });
        link.style("opacity",1);
    }
    
    
    function getParents(val,Noeuds){
        try{
            var parents = Noeuds.filter(function(a){
                return a.id == val.f_id || a.id == val.m_id;
                });
                return parents;
            }
        catch(Err){
            console.log('erreur lors de la récupération des parents (normale)');
        }
    }
    function getEnfants(val,Noeuds){
        try{
            var idParent = val.id;
            // On doit traiter également les couples : donc 
            if (val.id.includes('c_')){
                idParent = val.id.substring(2);
            }
            var enfants = Noeuds.filter(function(a){
                    return a.f_id == idParent || a.m_id == idParent;
                });
                return enfants;
            }
        catch(Err){
            console.log('erreur lors de la récupération des enfants (normale)');
        }
    }
    
    
    jQuery.fn.d3MouseOver = function () {
      this.each(function (i, e) {
        var evt = new MouseEvent("mouseover");
        e.dispatchEvent(evt);
      });
    };
    </script>
  
  </body>
</html>
