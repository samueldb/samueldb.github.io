<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link href="http://code.jquery.com/ui/1.11.4/themes/ui-lightness/jquery-ui.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script src="http://libs.cartocdn.com/cartodb.js/v3/3.15/cartodb.js" type="text/javascript"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js" type="text/javascript"></script>
    <style>
        svg{
          cursor: all-scroll;
        }
        .centralText{
          font: 23spx sans-serif;
          fill: #222;
          font-weight: bold;
        }
        .downwardNode circle{
          fill: #fff;
          stroke: #8b4513;
          stroke-width: 2.5px;
        }
        .upwardNode circle {
          fill: #fff;
          stroke: #37592b;
          stroke-width: 2.5px;
        }
        .downwardNode text,
        .upwardNode text {
          font: 12px sans-serif;
          font-weight:bold;
        }
        .downwardLink {
          fill: none;
          stroke: #8b4513;
          stroke-width: 3px;
          opacity: 0.2;
        }
        .upwardLink {
          fill: none;
          stroke: #37592b;
          stroke-width: 3px;
          opacity: 0.2;
        }
                
        .link {
            fill: none;
            stroke: #000;
        }
        .sibling {
            fill: none;
            stroke: blue;
        }
        .border {
            fill: none;
            shape-rendering: crispEdges;
            stroke: #aaa;
        }
        .node {
            stroke: red;
            fill:white;
        }
</style>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Travaux Carto</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Travaux Carto</h1>
        <h2 style="text-align:right;">by Samuel Deschamps Berger</h2>
        <a class="WIP" style="width:250px;height: 140px;"><div style="margin-left:25px;">Work In Progress </div><div style="margin-left:25px;"> <small> ajouté : <p>compatibilité Firefox / IE</p></small> </div></a>
      </div>
    </header>
    <ul id="nav"><!--
        --><li><a href="deschampsberger.html">Côté papa</a></li><!--
        --><li><a href="tripard.html">Côté maman</a></li><!--
        --><li><a href="add_personne.html">Ajout d'une personne</a></li><!--
        --><li><a href="cartographie.html">Cartographie</a></li><!--
        --><li><a href="village.html">Montfort</a></li>
    </ul>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
            <div id="titre"></div>
            <div id="graph" style="overflow-x:scroll"></div>
        </section>

        <aside id="sidebar">
            <div id="RecherchePersonne"></div>
        </aside>
      </div>
    </div>

    <script type="text/javascript">     // Compatibilité FF
    if (!Array.prototype.find) {
        Array.prototype.find = function (callback, thisArg) {
            "use strict";
            var arr = this,
            arrLen = arr.length,
            i;
            for (i = 0; i < arrLen; i += 1) {
                if (callback.call(thisArg, arr[i], i, arr)) {
                    return arr[i];
                }
            }
            return undefined;
        };
    }
    if (!String.prototype.includes) {
        String.prototype.includes = function() {
            'use strict';
            return String.prototype.indexOf.apply(this, arguments) !== -1;
        };
    }
    </script>
    
    
    <script type="text/javascript">
        var margin = {
            top: 10,
            right: 10,
            bottom: 10,
            left: 10
        },
        width = 840,
            height = 600;
        var kx = function (d) {
            return d.x - 20;
        };
        var ky = function (d) {
            return d.y - 10;
        };
        //thie place the text x axis adjust this to center align the text
        var tx = function (d) {
            return d.x - 3;
        };
        //thie place the text y axis adjust this to center align the text
        var ty = function (d) {
            return d.y + 3;
        };
        //make an SVG
        var svg = d3.select("#graph").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        //My JSON note the 
        //no_parent: true this ensures that the node will not be linked to its parent
        //hidden: true ensures that the nodes is not visible.
        var root = popNode()[0];
        var allNodes = flatten(root);
        //This maps the siblings together mapping uses the ID using the blue line
        var siblings = popNode()[1];

        
        
        // Compute the layout.
        var tree = d3.layout.tree().size([width, height]),
            nodes = tree.nodes(root),
            links = tree.links(nodes);

        // Create the link lines.
        svg.selectAll(".link")
            .data(links)
            .enter().append("path")
            .attr("class", "link")
            .attr("d", elbow);


        var nodes = svg.selectAll(".node")
            .data(nodes)
            .enter();

        //First draw sibling line with blue line
        svg.selectAll(".sibling")
            .data(siblings)
            .enter().append("path")
            .attr("class", "sibling")
            .attr("d", sblingLine);

        // Create the node rectangles.
        nodes.append("rect")
            .attr("class", "node")
            .attr("height", 20)
            .attr("width", 40)
            .attr("id", function (d) {
            return d.id;
        })
            .attr("display", function (d) {
            if (d.hidden) {
                return "none"
            } else {
                return ""
            };
        })
            .attr("x", kx)
            .attr("y", ky);
        // Create the node text label.
        nodes.append("text")
            .text(function (d) {
            return d.prenom;
        })
            .attr("x", tx)
            .attr("y", ty);


        /**
        This defines teh line between siblings.
        **/
        function sblingLine(d, i) {
            //start point
            var start = allNodes.filter(function (v) {
                if (d.source.id == v.id) {
                    return true;
                } else {
                    return false;
                }
            });
            //end point
            var end = allNodes.filter(function (v) {
                if (d.target.id == v.id) {
                    return true;
                } else {
                    return false;
                }
            });
            //define teh start coordinate and end co-ordinate
            var linedata = [{
                x: start[0].x,
                y: start[0].y
            }, {
                x: end[0].x,
                y: end[0].y
            }];
            var fun = d3.svg.line().x(function (d) {
                return d.x;
            }).y(function (d) {
                return d.y;
            }).interpolate("linear");
            return fun(linedata);
        }

        /*To make the nodes in flat mode.
        This gets all teh nodes in same level*/
        function flatten(root) {
            var n = [],
                i = 0;

            function recurse(node) {
                if (node.children) node.children.forEach(recurse);
                if (!node.id) node.id = ++i;
                n.push(node);
            }
            recurse(root);
            return n;
        }
        /** 
        This draws the lines between nodes.
        **/
        function elbow(d, i) {
            if (d.target.no_parent) {
                return "M0,0L0,0";
            }
            var diff = d.source.y - d.target.y;
            //0.40 defines the point from where you need the line to break out change is as per your choice.
            var ny = d.target.y + diff * 0.40;

            linedata = [{
                x: d.target.x,
                y: d.target.y
            }, {
                x: d.target.x,
                y: ny
            }, {
                x: d.source.x,
                y: d.source.y
            }]

            var fun = d3.svg.line().x(function (d) {
                return d.x;
            }).y(function (d) {
                return d.y;
            }).interpolate("step-after");
            return fun(linedata);
        }
        
        function popNode(){
            var res = [];
            nodes = [];
            links = [];
                        
            var sql_statement = "SELECT * FROM nodes WHERE arbre = '1' OR arbre = '2'";
            $.getJSON('https://samueldeschampsberger.cartodb.com/api/v2/sql/?q='+sql_statement, function(data_json) {
                if (data_json.rows.length == 0){
                    // Il n'y a personne dans la table
                    document.getElementById('titre').innerHTML = "Il n'y a pas encore de personne dans cet arbre !";
                }
                else if (data_json.rows.length > 0){
                    // Pour chaque ligne, on l'ajoute au tableau des noeuds. 
                    // Et on formatte le tableau pour qu'il soit exploitable par D3
                    // var nodes, links, liste_couple;
                    liste_couple = [];
                    for (var r of data_json.rows){
                        // On remplit les personnes
                        nodes.push({"type":r.genre,"id":r.own_id,"parent":null,"no_parent":"false","name":r.nom,"prenom":r.prenom,"f_id":r.father_id,"m_id":r.mother_id,"c_id":r.couple_id,"dBirth":r.date_naissance,"dDie":r.date_deces,"dMar":r.date_mariage,"job":r.profession,"comm":r.commentaire,"arbre":r.arbre,"adr_photo":r.adr_photo});
                        // Si 1 des 2 parents est en couple et n'a pas de parent, on ajoute un no_parent: true
                        if ((r.couple_id != null && r.couple_id != "null" && r.father_id == "null" && r.mother_id == "null")){
                            var isinliste = 0;
                            r.no_parent = "true";
                            //for (var lc of liste_couple){
                            //    if (lc.id_c == r.own_id){
                            //        // Si l'id est déjà dans cette liste, on ne l'ajoute pas
                            //        isinliste = 1;
                            //    }
                            //}
                            //if (isinliste == 0){
                            //    var Pere = nodes.find(function(a){return a.id == r.father_id});
                            //    var homme = nodes.find(function(a){return a.id == r.own_id && r.genre == "M"});
                            //    var saFemme;
                            //    if (homme){
                            //        nodes.push({"type":"couple","id":"c_"+r.couple_id,"parent":null,"name":homme.nom,"prenom":homme.prenom,"id_homme":r.own_id,"id_femme":r.couple_id,"dMar":r.date_mariage,"arbre":r.arbre});
                            //        liste_couple.push({"id_c":r.couple_id,"id_homme":r.own_id});
                            //    }
                            //}
                        }
                        // On calcul les liens 
                        var pereExiste = nodes.find(function(a){return a.id == r.father_id});
                        var mereExiste = nodes.find(function(a){return a.id == r.mother_id});
                        var source = [];
                        var target  =[];
                        if (r.father_id == null || r.father_id == " " || r.father_id == "null" || typeof(pereExiste) == 'undefined'){}
                        else {
                            source.push({"id":r.father_id,"name":r.prenom});
                            target.push({"id":r.own_id,"name":r.prenom});
                            }
                        if (r.mother_id == null || r.mother_id == " " || r.mother_id == "null"  || typeof(mereExiste) == 'undefined'){}
                        else {
                            source.push({"id":r.mother_id,"name":r.prenom});
                            target.push({"id":r.own_id,"name":r.prenom});
                        }
                        links.push({"source":source,"target":target});
                    }
                    // Une fois les nodes remplis, on ajoute "parent" des noeuds des personnes en couple : 
                    for (var p of nodes){
                        for (var lc of liste_couple){
                            if (p.id == lc.id_c || p.id == lc.id_homme){
                                p.parent = "c_"+lc.id_c;
                            }
                        }
                    }
                }
            });
            res[0] = nodes;
            res[1] = links;
            return res;
        }
            
    </script>
  
  </body>
</html>
